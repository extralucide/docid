#!/usr/bin/env python 2.7.3# -*- coding: utf-8 -*-__author__ = 'Olivier.Appere'from openpyxl import load_workbookfrom copy import deepcopyimport refrom check_llr import CheckLLRfrom datetime import datetimetry:    from Tkinter import *    ##    import Tkinter              # Python 2    import ttkexcept ImportError:    from tkinter import *from tool import Toolfrom synergy import Synergyfrom math import floorimport timefrom os.path import joinfrom openpyxl import load_workbook,Workbook#from openpyxl.worksheet import range_boundariesfrom openpyxl.compat import rangefrom openpyxl.utils import get_column_letter#from openpyxl.drawing import Imagefrom openpyxl.styles import Font,PatternFill,Border,Side,Alignmentfrom openpyxl.styles.colors import RED,YELLOW,WHITE,GREENfrom openpyxl.styles.borders import BORDER_THIN,BORDER_MEDIUMfrom openpyxl.worksheet.datavalidation import DataValidationfrom openpyxl.formatting.rule import CellIsRule, FormulaRulefrom openpyxl.comments import Commentfrom openpyxl.utils import get_column_letter,range_boundariesfrom ccb import CCBtry:    import win32api    import win32com.client as win32    import pythoncom    from win32com.client import constantsexcept ImportError,e:    print efrom excel import Excel,Styleclass CheckIS(CheckLLR,Synergy):    #nb_expected_srs_rules = 33    #nb_expected_srs_req_rules = 22    # TODO: Make configurable    expected_srs_rules = ["SRS_01","SRS_06","SRS_07","SRS_09","SRS_10","SRS_11","SRS_12","SRS_13","SRS_14","SRS_15",                          "SRS_23","SRS_16","SRS_18","SRS_19","SRS_20","SRS_21","SRS_22","SRS_24","SRS_25","SRS_52",                          "SRS_59","SRS_60","SRS_28","SRS_29","SRS_30","SRS_31","SRS_32","SRS_33","SRS_34","SRS_35",                          "SRS_36","SRS_08","SRS_17"]    expected_sds_rules =["SDS_001","SDS_158","SDS_153","SDS_154","SDS_006","SDS_007","SDS_008","SDS_143","SDS_015","SDS_016","SDS_017","SDS_155","SDS_156",                         "SDS_018","SDS_019","SDS_020","SDS_166","SDS_021","SDS_022","SDS_023","SDS_146","SDS_024","SDS_025","SDS_026","SDS_027","SDS_161",                         "SDS_028","SDS_029","SDS_030","SDS_031","SDS_032","SDS_033","SDS_034","SDS_035","SDS_036","SDS_037","SDS_038","SDS_039",                         "SDS_040","SDS_041","SDS_042","SDS_043","SDS_044","SDS_045","SDS_046","SDS_047","SDS_048","SDS_049",                         "SDS_050","SDS_051","SDS_052","SDS_053","SDS_054","SDS_055","SDS_056","SDS_057","SDS_147","SDS_159",                         "SDS_058","SDS_059","SDS_060","SDS_061","SDS_062","SDS_063","SDS_064","SDS_065","SDS_069","SDS_144",                         "SDS_066","SDS_163","SDS_162","SDS_071","SDS_072","SDS_073","SDS_074","SDS_075","SDS_076","SDS_077",                         "SDS_078","SDS_079","SDS_080","SDS_081","SDS_082","SDS_083","SDS_165","SDS_084","SDS_086","SDS_168",                         "SDS_169","SDS_088","SDS_104","SDS_105","SDS_106","SDS_107","SDS_108","SDS_109","SDS_110","SDS_111",                         "SDS_112","SDS_113","SDS_114","SDS_164","SDS_115","SDS_116","SDS_117","SDS_118","SDS_119","SDS_120",                         "SDS_121","SDS_150","SDS_122","SDS_123","SDS_124","SDS_125","SDS_151","SDS_152","SDS_160"]    expected_sds_req_rules_dico = {"SDS_REQ_090":"Both",                                   "SDS_REQ_091":"Both",                                   "SDS_REQ_167":"Both",                                   "SDS_REQ_092":"Both",                                   "SDS_REQ_093":"Both",                                   "SDS_REQ_094":"Both",                                   "SDS_REQ_095":"Both",                                   "SDS_REQ_096":"Both",                                   "SDS_REQ_097":"Both",                                   "SDS_REQ_098":"Both",                                   "SDS_REQ_099":"Both",                                   "SDS_REQ_157":"Both",                                   "SDS_REQ_100":"Both",                                   "SDS_REQ_101":"Both",                                   "SDS_REQ_148":"Both",                                   "SDS_REQ_149":"Both",                                   "SDS_REQ_102":"Both",                                   "SDS_REQ_170":"Both",                                   "SDS_REQ_103":"Both",                                   "SDS_REQ_126":"Both",                                   "SDS_REQ_127":"Both",                                   "SDS_REQ_128":"Both",                                   "SDS_REQ_129":"Both",                                   "SDS_REQ_130":"Both",                                   "SDS_REQ_131":"Both",                                   "SDS_REQ_133":"Both",                                   "SDS_REQ_135":"Both",                                   "SDS_REQ_137":"Both",                                   "SDS_REQ_138":"Both",                                   "SDS_REQ_140":"Both",                                   "SDS_REQ_141":"Deleted",                                   "SDS_REQ_139":"Both",                                   "SDS_REQ_145":"Both",                                   "SDS_REQ_134":"Both",                                   "SDS_REQ_142":"Both"                                   }    # SRTS ET3157-E issue 1.5    expected_srs_req_rules_dico = {"SRS_REQ_37":"Both",                                   "SRS_REQ_38":"Both",                                   "SRS_REQ_39":"Both",                                   "SRS_REQ_40":"Existent",                                   "SRS_REQ_41":"Both",                                   "SRS_REQ_42":"Both",                                   "SRS_REQ_43":"Both",                                   "SRS_REQ_44":"Both",                                   "SRS_REQ_45":"Both",                                   "SRS_REQ_46":"Both",                                   "SRS_REQ_47":"Both",                                   "SRS_REQ_48":"Both",                                   "SRS_REQ_49":"Both",                                   "SRS_REQ_50":"Deleted",                                   "SRS_REQ_51":"Existent",                                   "SRS_REQ_53":"Existent",                                   "SRS_REQ_54":"Existent",                                   "SRS_REQ_56":"Existent",                                   "SRS_REQ_57":"Existent",                                   "SRS_REQ_61":"Existent",                                   "SRS_REQ_62":"Existent",                                   "SRS_REQ_63":"Existent"}    def set_border_is(self,ws, cell_range,bg=WHITE,align=True):        font = Font(name='Arial',size=10,bold=False)        if align:            alignment=Alignment(horizontal='center',vertical='center',wrap_text=False,shrink_to_fit=True)        else:            alignment=Alignment(wrap_text=False,shrink_to_fit=True)        if bg != WHITE:            style_border = Style(border=Border(left=Side(border_style=BORDER_MEDIUM),                                               right=Side(border_style=BORDER_MEDIUM),                                                    top=Side(border_style=BORDER_MEDIUM),                                                    bottom=Side(border_style=BORDER_MEDIUM)),                                      alignment=alignment,                                      fill=PatternFill(patternType='solid',start_color=bg),                                      font=font)        else:            style_border = Style(border=Border(left=Side(border_style=BORDER_MEDIUM),                                               right=Side(border_style=BORDER_MEDIUM),                                                    top=Side(border_style=BORDER_MEDIUM),                                                    bottom=Side(border_style=BORDER_MEDIUM)),                                      alignment=alignment,                                      font=font)        #row = ws.iter_rows(cell_range)        min_col, min_row, max_col, max_row = range_boundaries(cell_range.upper())        #print "TEST:",min_col, min_row, max_col, max_row        for index_row, rows in enumerate(ws.iter_rows(cell_range)):        #for row in rows:            index_column = 0            for row in rows:                Style.setStyleRow(row,style_border)                index_column +=1    def getIssue(self,                 req,                 dico_upper):        """        Check upper requirement in IS is included in upper specification        :param req: upper requirement from UPPER REQ ANALYSIS worksheet of IS workbook        :param dico_upper: dictionary of requirement like ex:                            SSCS_ACLog_790 {'status': u'MATURE',                                            'terminal': 'EMPTY',                                            'additional': 'EMPTY',                                            'conformity': u'YES',                                            'derived': 'EMPTY',                                            'allocation': u'HW',                                            'body': u'The ACLog shall meet the Power Input requirements defined in section 16 of RTCA/DO-160G Category A(NF) with the exceptions described in Power Quality document RAE-BA700-103 rev C.',                                            'safety': 'EMPTY',                                            'verification': 'EMPTY',                                            'rationale': 'EMPTY',                                            'issue': u'3',                                            'refer': u'[SES-ACEPC-292]'}        :return:        """        #for document,tbl_reqs_in_upper_doc in dico_upper.iteritems():        if req in dico_upper:            value = dico_upper[req]            # Get issue of upper requirement from IS UPPER_REQ_ANALYSIS worksheet            result = CheckLLR.getAtribute(value,"issue")            if result not in (None,'None','EMPTY'):                try:                    issue = int(result)                except ValueError,e:                    print "getIssue",e                    issue = result            else:                issue = "False"        else:            issue = "Unknown"        return issue    @staticmethod    def validationReqAnalysis(prompt_txt="Please select from the list OK, NOK or NOT VERIFIED"):        # Create a data-validation object with list validation        dv = DataValidation(type="list", formula1='"OK,NOK,NOT VERIFIED"', allow_blank=True)        # Optionally set a custom error message        dv.error ='Your entry is not in the list'        dv.errorTitle = 'Invalid Entry'        # Optionally set a custom prompt message        dv.prompt = prompt_txt        dv.promptTitle = 'List Selection'        return dv    @staticmethod    def validationReqReview(prompt_txt="Please select from the list OK, NOK, PARTIALLY VERIFIED (NOK) and PARTIALLY VERIFIED (OK)"):        # Create a data-validation object with list validation        dv = DataValidation(type="list", formula1='"OK,NOK,PARTIALLY VERIFIED (NOK),PARTIALLY VERIFIED (OK)"', allow_blank=True)        # Optionally set a custom error message        dv.error ='Your entry is not in the list'        dv.errorTitle = 'Invalid Entry'        # Optionally set a custom prompt message        dv.prompt = prompt_txt        dv.promptTitle = 'List Selection'        return dv    def exportIS(self,                 filename_is="test",                 project="SW_TEST",                 reference="ETXXXX",                 issue="1.0",                 release="SW_TEST/01",                 author="O. Appere",                 title="Software Requirement Data",                 default_status = "OK",                 reviewer_name = "Nobody",                 dico_upper={},                 tbl_cr=[],                 type="SWRD"):        """        Create Inspection Sheet from specification document        :param filename_is:        :param reference:        :param issue:        :param release:        :param dico_upper:        :return:        """        # Init        dv_review = self.validationReqAnalysis("OK: if objective is completely covered, NOK: if objective i not at all or partially covered, NOT VERIFIED: if objective is not verified on current version")        dv_doc_review = self.validationReqAnalysis("SVP 4.2.4.7: NOK if the verified item does not comply or complies partially with the SRTS rule, NOT VERIFIED if the high-level requirement is not verified, OK if one of the verified item complies with the SRTS rule")        req_analysis_prompt = "NOK if SwRD requirement does not comply with at least one or more linked upper requirement or derived requirement justification is not correct. " \                              "NOT VERIFIED if SwRD requirement compliance is not verified, " \                              "OK if SwRD requirement complies with all linked upper requirements or derived requirement justification is correct."        req_analysis_prompt = "OK if SwRD requirement complies with all linked upper requirements or derived requirement justification is correct."        dv_req_analysis = self.validationReqAnalysis(req_analysis_prompt)        dv_upper_req_analysis = self.validationReqAnalysis("NOK if upper requirement is not fully developed into SwRD requirements, NOT VERIFIED if upper requirement refinement is not verified, OK if upper requirement is fully developed into SwRD requirements.")        req_review_prompt = "SVP 4.2.4.8: NOK if the verified requirement does not comply with at least one rule, " \                            "PARTIALLY VERIFIED (NOK) if one of the rules is not verified on the last requirement issue and at least one verified rule is NOK, " \                            "PARTIALLY VERIFIED (OK) if one of the rule is not verified on the last requirement issue and all verified rules are OK, " \                            "OK otherwise."        req_review_prompt = "SVP 4.2.4.8: OK if the verified requirement does comply with all rules"        dv_req_review = self.validationReqReview(req_review_prompt)        redFill = PatternFill(start_color=RED,end_color=RED,fill_type='solid')        greenFill = PatternFill(start_color=GREEN,end_color=GREEN,fill_type='solid')        orangeFill = PatternFill(start_color=YELLOW,end_color=YELLOW,fill_type='solid')        # Workbook loading        if type == "SWRD":            wb = load_workbook(filename = join('template',self.is_export_tpl_name))        elif type == "SWDD":            wb = load_workbook(filename = join('template',self.is_export_swdd_tpl_name))        # CONTEXT        ws = wb.get_sheet_by_name(name = 'CONTEXT')        Style.putLogo(ws,image="very_small_logo_zodiac.jpeg")        style_border = Style(border=Border(            left=Side(border_style=BORDER_MEDIUM),            right=Side(border_style=BORDER_MEDIUM),            top=Side(border_style=BORDER_MEDIUM),            bottom=Side(border_style=BORDER_MEDIUM)))        for position in ('C5','C10','C16','C21'):            cellule = ws[position]            print "CELLULE",cellule            #cellule.style = style_border        ws.cell('C6').value = project        ws.cell('C7').value = release        ws.cell('C8').value = reviewer_name        ws.cell('C9').value = datetime.now()        # Document inspected        ws.cell('C11').value = title        ws.cell('C12').value = reference        ws.cell('C13').value = issue        ws.cell('C14').value = author        row = 22        cr_line = 1        for cr in tbl_cr:            if cr_line > 1:                self.set_border_is(ws, "B{:d}:C{:d}".format(row,row))                ws.cell('B%s'%(row)).value = "CR {:s}".format(cr[0].zfill(4))                ws.cell('C%s'%(row)).value = cr[1]                row += 1            cr_line += 1        Style.set_border_is(ws, "C22:C38",align=False)        # REVIEW        ws = wb.get_sheet_by_name(name = 'REVIEW')        for row_id in range (2,13):            current_cell = ws.cell('C%s'%(row_id))            current_cell.value = default_status            ws.cell('D%s'%(row_id)).value = reviewer_name            ws.cell('E%s'%(row_id)).value = issue        ws.add_data_validation(dv_review)        row = 13        dv_review.ranges.append('C1:C%s'%(row - 1))        cell_square = 'C3:C%s'%(row - 1)        for formula in (['"OK"'],['"NOK"'],['"NOT VERIFIED"']):            ws.conditional_formatting.add(cell_square,                                          CellIsRule(operator='equal',                                                                 formula=formula,                                                                 stopIfTrue=True,                                                                 fill=greenFill))        #ws.conditional_formatting.add(cell_square,        #                              CellIsRule(operator='equal',        #                                         formula=['"NOK"'],        #                                         stopIfTrue=True,        #                                         fill=redFill))        #ws.conditional_formatting.add(cell_square,        #                              CellIsRule(operator='equal',        #                                         formula=['"NOT VERIFIED"'],        #                                         stopIfTrue=True,        #                                         fill=orangeFill))        # DOC REVIEW        # NOK if the verified item does not comply or complies partially to the SRTS rule        # NOT VERIFIED if the high-level requirement is not verified,        # OK if one the verified item complies to the SRTS rule        ws = wb.get_sheet_by_name(name = 'DOC REVIEW')        if type == "SWRD":            result = False        elif type == "SWDD":            result = Tool.getAll_SDTS_Rule_by_req(by_req=False)            nb_rules = len(result)            print "Found {:d} general rules.".format(nb_rules)        row_id = 2        if result:            for id,description in sorted(result):            #    print "SDS_{:s}: {:s}".format(id,Tool.replaceNonASCII(description))            #for row_id in range (2,35):                current_cell = ws.cell('A%s'%(row_id))                current_cell.value = "SDS_{:s}".format(id)                current_cell = ws.cell('B%s'%(row_id))                current_cell.value = "{:s}".format(Tool.replaceNonASCII(description))                current_cell = ws.cell('C%s'%(row_id))                current_cell.value = default_status                ws.cell('D%s'%(row_id)).value = reviewer_name                ws.cell('E%s'%(row_id)).value = issue                row_id += 1        ws.add_data_validation(dv_doc_review)        #row = 35        dv_doc_review.ranges.append('C1:C%s'%(row - 1))        cell_square = 'C3:C%s'%(row - 1)        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        # REQ REVIEW        ws = wb.get_sheet_by_name(name = 'REQ REVIEW')        if type == "SWRD":            result = False            max_col_idx = 72        elif type == "SWDD":            result = Tool.getAll_SDTS_Rule_by_req(by_req=True)            nb_rules = len(result)            print "Found {:d} rules for requirements.".format(nb_rules)            col_idx = 6            for id,description in sorted(result):                clean_description = Tool.replaceNonASCII(description)                print "SDS_REQ_{:s}: {:s}".format(id,clean_description)                #for col_idx in range(6,72,3):                col = get_column_letter(col_idx)                current_cell = ws.cell('%s1'%(col))                current_cell.value =  "SDS_REQ_{:s}".format(id)                comment = Comment(clean_description, "O. Appere")                current_cell.comment = comment                col_idx += 3                #col = get_column_letter(col_idx + 1)                #current_cell = ws.cell('%s1'%(col))                #current_cell.value = issue            max_col_idx = col_idx        row = 3        self.set_border_is(ws, "F2:BS2")        # sort requirements        #print "List requirements",self.tbl_file_llr_wo_del        tbl_list_req=[]        for name,list_req in self.tbl_file_llr_wo_del.iteritems():            for req in list_req:                tbl_list_req.append(req)        tbl_list_req.sort()        print "tbl_list_req",tbl_list_req        for req in tbl_list_req:            print "self.tbl_list_llr",self.tbl_list_llr            value = self.tbl_list_llr[req]            # Discard deleted requirements            current_cell = ws.cell('A%s'%(row))            current_cell.value = '%s' % (req)            issue = CheckLLR.getAtribute(value,"issue")            current_cell = ws.cell('B%s'%(row))            current_cell.value = '%s' % (issue)            current_cell = ws.cell('C%s'%(row))            current_cell.value = default_status            current_cell = ws.cell('D%s'%(row))            current_cell.value = ""            current_cell = ws.cell('E%s'%(row))            current_cell.value = reviewer_name            for col_idx in range(6,max_col_idx,3):                col = get_column_letter(col_idx)                current_cell = ws.cell('%s%s'%(col, row))                current_cell.value = reviewer_name                col = get_column_letter(col_idx + 1)                current_cell = ws.cell('%s%s'%(col, row))                current_cell.value = issue            self.set_border_is(ws, "A{:d}:BS{:d}".format(row,row))            row += 1        cell_square = 'C3:C%s'%(row - 1)        #for formula,fill in ((['"OK"'],greenFill,font=Font()),        #                     (['"NOK"'],redFill,font=Font()),        #                     (['"NOT VERIFIED"'],orangeFill,font=Font()),        #                     (['"PARTIIALLY VERIFIED (OK)"'],orangeFill,font=Font()),        #                     (['"PARTIIALLY VERIFIED (NOK)"'],)):        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"PARTIIALLY VERIFIED (OK)"'],                                                 stopIfTrue=True,                                                 fill=orangeFill,                                                 font=Font(color=GREEN)))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"PARTIIALLY VERIFIED (NOK)"'],                                                 stopIfTrue=True,                                                 fill=orangeFill,                                                 font=Font(color=RED)))        ws.add_data_validation(dv_req_review)        dv_req_review.ranges.append('C1:C%s'%(row - 1))        ws = wb.get_sheet_by_name(name = 'REQ ANALYSIS')        self.set_border_is(ws, "A1:A2",bg="BBBBBBBB")        self.set_border_is(ws, "B1:B2",bg="BBBBBBBB")        self.set_border_is(ws, "E1:E2",bg="BBBBBBBB")        self.set_border_is(ws, "F1:F2",bg="BBBBBBBB")        row = 3        for req in tbl_list_req:            value = self.tbl_list_llr[req]            # Discard deleted requirements            current_cell = ws.cell('A%s'%(row))            current_cell.value = '%s' % (req)            issue = CheckLLR.getAtribute(value,"issue")            current_cell = ws.cell('B%s'%(row))            current_cell.value = '%s' % (issue)            current_cell = ws.cell('E%s'%(row))            current_cell.value = '%s' % (issue)            current_cell = ws.cell('C%s'%(row))            current_cell.value = default_status            current_cell = ws.cell('D%s'%(row))            current_cell.value = reviewer_name            self.set_border_is(ws, "A{:d}:F{:d}".format(row,row))            row += 1        cell_square = 'C3:C%s'%(row - 1)        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        ws.add_data_validation(dv_req_analysis)        dv_req_analysis.ranges.append('C1:C%s'%(row - 1))        ws = wb.get_sheet_by_name(name = 'UPPER REQ ANALYSIS')        self.set_border_is(ws, "A1:A2",bg="BBBBBBBB")        self.set_border_is(ws, "B1:B2",bg="BBBBBBBB")        self.set_border_is(ws, "D1:D2",bg="BBBBBBBB")        self.set_border_is(ws, "F1:F2",bg="BBBBBBBB")        row = 3        # Create a data-validation object with list validation        #dv = DataValidation(type="list", formula1='"OK,NOK,NOT VERIFIED"', allow_blank=True)        # Optionally set a custom error message        #dv.error ='Your entry is not in the list'        #dv.errorTitle = 'Invalid Entry'        # Optionally set a custom prompt message        #dv.prompt = 'Please select from the list OK, NOK or NOT VERIFIED'        #dv.promptTitle = 'List Selection'        # Add the data-validation object to the worksheet        ws.add_data_validation(dv_upper_req_analysis)        line_value = []        for req in self.list_upper_req:            if req in dico_upper:                value = dico_upper[req]                issue_str = CheckLLR.getAtribute(value,"issue")                if issue_str not in (None,"None"):                    try:                        issue = int(issue_str)                    except ValueError:                        issue = "Unknown"                else:                    issue = "Unknown"            else:                issue = "Unknown"            line_value.append((req,default_status,issue,reviewer_name))        print "line_value",line_value        if line_value is not None:            for req,default_status,issue,reviewer_name in sorted(line_value):                self.set_border_is(ws, "A{:d}:F{:d}".format(row,row))                current_cell = ws.cell('A%s'%(row))                current_cell.value = '%s' % (req)                current_cell = ws.cell('B%s'%(row))                current_cell.value = issue                current_cell = ws.cell('C%s'%(row))                current_cell.value = default_status                current_cell = ws.cell('E%s'%(row))                current_cell.value = issue                current_cell = ws.cell('D%s'%(row))                current_cell.value = reviewer_name                row += 1        dv_upper_req_analysis.ranges.append('C1:C%s'%(row - 1))        # Format if cell is NOK        font = Font(name='Arial',size=10,bold=False,color=RED)        cell_square = 'C3:C%s'%(row - 1)        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        #fill=redFill))        #ws.conditional_formatting.add('C3:C%s'%(row - 1),FormulaRule(formula=['E1=NOK'],fill=redFill))        ws = wb.get_sheet_by_name(name = 'CONTEXT')        # save the file        filename = "IS_%s_%d.xlsx" % (filename_is,floor(time.time()))        # Patch for conditional formatting        ws.conditional_formatting.setDxfStyles(wb)        wb.save(join("result",filename))        return filename    def __init__(self,                 basename="",                 hlr_selected=False,                 **kwargs):        for key in kwargs:            self.__dict__[key] = kwargs[key]        if "session_started" in self.__dict__:            Synergy.__init__(self,self.session_started)        if "callback" in self.__dict__:            print "CALLBACK",self.__dict__["callback"]            CheckLLR.__init__(self,                              basename,                              hlr_selected,                              callback=self.__dict__["callback"])        else:            print "NO CALLBACK"            CheckLLR.__init__(self,                              basename,                              hlr_selected)        self.index_row = 0        self.index_column = 0        self.nb_cell_read = 0        self.context_issue = ""        self.log_filename = None        self.log_handler = None        self.tbl_cr = []        self.tbl_is_cr_id = []        self.applicable_docs = {}        self.is_release = ""        self.is_baseline = ""        self.resetKeywords()        self.dico_remarks = {}        self.resetSheetsList()        # Patch temporaire        self.component = ""        self.list_cr = []        self.list_cr_not_found = []        self.list_rules_unknown = []    def getRemarkInOverfolders(self,tbl_remarks_other_folders):        nb_remarks = len(self.dico_remarks)        # list_remarks_other_folders = []        #print "DICO:",self.dico_remarks        list_remarks_other_folders = self.dico_remarks.values()        #print "list_remarks_other_folders",list_remarks_other_folders        for tbl_remark in list_remarks_other_folders:            for remark_id in tbl_remark:                if remark_id not in tbl_remarks_other_folders:                    try:                        remark_id_int = int(remark_id)                    except ValueError:                        remark_id_int = 0                    tbl_remarks_other_folders.append(remark_id_int)        return nb_remarks    def CheckISGeneric(self,                       filename_is,                       skip_change_synergy_var=False,                       verif_issue_cr_process_start=999):        self.dico_remarks = {}        self.nb_error = 0        # Launch clock        dico_timestamp={}        dico_timestamp["begin_script"] = datetime.now()        #try:        #    wb = load_workbook(filename = filename_is, use_iterators = True)        #except: # InvalidFileException:        #    self.log("File {:s} opening error.".format(filename_is),gui_display=True)        #    return False        wb = self.loadWorkbook(filename_is)        # CONTEXT        self.current_folder = "CONTEXT"        self.log(CheckIS.header("CONTEXT"),gui_display=True)        # Le status de la cellule E6 et la somme des "Open Items Count"        # Pour chaque onglet on compte le nombre de cellules contenant un identifiant de remarque        dico_context = deepcopy(self.keywords)        self.parseContext(wb,dico_context)        #for row,value  in dico_context.iteritems():        #    print "DICO_CONTEXT:",row,value        tbl_cr = []        doc_inspected = self.checkContext(dico_context)        context_issue = doc_inspected[1]        self.log("Document inspected has the reference {:s} and the version {:s}".format(doc_inspected[0],context_issue),gui_display=True)        self.log(CheckIS.header("SPECIFICATION PARSING PART 2"),gui_display=True)        self.log("Modifications implemented in the release {:s}".format(self.is_release),gui_display=True)        for modif in self.tbl_dico_modifs:            # Display only the last modifications in the release of specification            context_version = CheckIS.getVersion(context_issue)            modif_version = CheckIS.getVersion(modif["issue"])            if context_version == modif_version:                line = "Issue {:s}: {:s}".format(modif["issue"],Tool.removeNonAscii(modif["modif"]))                self.log(line,gui_display=True)        # Comparison of CR with Change database        dico_timestamp["begin_change_query"] = datetime.now()        if not skip_change_synergy_var:            query = 'query -u -sby problem_number "(cvtype=\'problem\') and (CR_implemented_for=\'{:s}\')" ' \                    '-f "%problem_number;%crstatus;%CR_domain"'.format(self.is_release) # ;%CR_functional_impact            stdout,stderr = self.ccm_query(query,"Get CRs")            self.log(query + " completed.")            #self.master_ihm.defill()            if stdout != "":                tbl_cr_change = []                output = stdout.splitlines()                for cr in output:                    m = re.match(r'^([0-9]*);(EXCR|SyCR|ECR|SACR|HCR|SCR|BCR|PLDCR)_?(.*);(.*)',cr)                    if m:                        cr_id = m.group(1)                        cr_status = m.group(3)                        cr_domain = m.group(4)                        tbl_cr_change.append(cr_id)                        self.log("   Found {:s} {:s} with status {:s} for release {:s}".format(cr_domain,cr_id,cr_status,self.is_release),gui_display=True)                self.cmpCR(tbl_cr_change,                           self.tbl_is_cr_id)        # Comparison of docs with Synergy database        dico_timestamp["begin_synergy_query"] = datetime.now()        if not skip_change_synergy_var:            list_projects = self._getProjectsList_wo_ihm(self.is_release,self.is_baseline)            print "list_projects",list_projects            sub_list_rel_bas_proj = []            sub_list_projects = []            for project in list_projects:                m = re.match(r'^CODE_(.*)',project)                if not m:                    prj_name, prj_version = self.getProjectInfo(project)                    sub_list_projects_part = self.findSubProjects(prj_name,prj_version,sub_list_rel_bas_proj,mute=True)                    #print "Synergy thread L1747:",sub_list_projects_part                    sub_list_projects.extend(sub_list_projects_part)                    #print "Synergy thread L1749:",sub_list_projects            sub_list_projects.extend(list_projects)            #print "sub_list_projects",sub_list_projects            list_synergy_docs = []            for project in sub_list_projects:                match_code = re.match(r'^CODE_(.*)',project)                match_plans = re.match(r'^SW_PLAN(.*)',project)                if not match_code:                    # Exclude code source project                    if not match_plans:                        exclude=["Data sheet","CCB_MINUTES"]                        folder_to_search = "Input_Data"                    else:                        exclude=["CCB_MINUTES","SQAP","SDP"]                        folder_to_search = "SW_PLAN"                    self.log("Make Synergy query to get documents in project {:s} in \"{:s}\" folder".format(project,folder_to_search),gui_display=True)                    #print "project treated:",project                    list_synergy_docs_part = self.getItemsInFolder(folder_keyword = folder_to_search,                                                              project=project,                                                              baseline=self.is_baseline,                                                              release=self.is_release,                                                              exclude=exclude,                                                              only_name=False,                                                              with_extension=True,                                                              mute=True)                    #print "list_synergy_docs",list_synergy_docs                    list_synergy_docs.extend(list_synergy_docs_part)            for docs in list_synergy_docs:                m = re.match(r'^(IS|IP|CRI)(.*)',docs)                if not m:                    # Exclude Inspection Sheets                    formatted_doc = re.sub(r'^(.*)_(ET|GS)([0-9]{4})(_[ES])?\.(.*) issue (.*)',r'\2\3/\6: \1 (\5)',docs)                    docs_ljust = formatted_doc.ljust(60)                    self.log("   Found input document {:s} for release {:s}".format(docs_ljust,self.is_release),gui_display=True)        dico_timestamp["end_synergy_query"] = datetime.now()        # REVIEW        self.current_folder = "REVIEW"        self.log(CheckIS.header("REVIEW"),gui_display=True)        list_general_rules = []        self.parseReview(wb,'A2:F50',1,list_general_rules)        nb_review_nok = self.checkStatus(list_general_rules,                                         context_issue)        self.getRemarks(list_general_rules,"REVIEW")        # DOC REVIEW        self.current_folder = "DOC REVIEW"        self.log(CheckIS.header("DOC REVIEW"),gui_display=True)        list_doc_rules = []        self.parseReview(wb,'A2:F100',2,list_doc_rules)        nb_doc_review_nok = self.checkStatus(list_doc_rules,                                             context_issue)        self.getRemarks(list_doc_rules,"DOC REVIEW")        self.log(CheckIS.header("REMARKS"),gui_display=True)        self.current_folder = "REMARKS"        # REMARKS        #        # - Check numbering of remarks is an unbroken sequence        # - Check remarks opened        #        tbl_remarks_other_folders = []        nb_remarks = self.getRemarkInOverfolders(tbl_remarks_other_folders)        list_remarks = []        self.parseReview(wb,'A2:K2000',6,list_remarks)        self.list_cr = []        nb_remarks_open = self.checkRemarks(list_remarks,                                            self.list_cr,                                            verif_issue_cr_process_start)        #for x in list_remarks:        #    print "LINE:",x        #print ws.columns        #sheet_ranges = wb['CONTEXT']        #print(sheet_ranges['E6'].value)        self.log("Found {:d} remarks in other folders than REMARK.".format(nb_remarks),gui_display=True)        self.log("Found {:d} remarks OPEN in folder REMARK.".format(nb_remarks_open),gui_display=True)        if nb_remarks != nb_remarks_open:            self.nb_error += 1        nb_errors = len(self.dico_errors)        nb_warnings = len(self.dico_warnings)        self.log("{:d} errors found.".nb_errors,gui_display=True)        self.log("{:d} warnings raised.".nb_warnings,gui_display=True)        self.log("{:d} cells read.".format(self.nb_cell_read),gui_display=True)        self.log("In REVIEW, {:d} errors found.".format(nb_review_nok),gui_display=True)        self.log("In DOC REVIEW, {:d} errors found.".format(nb_doc_review_nok),gui_display=True)        self.log("In REMARKS, {:d} remarks OPEN.".format(nb_remarks_open),gui_display=True)        dico_timestamp["end_script"] = datetime.now()        duree_execution_script = dico_timestamp["end_script"] - dico_timestamp["begin_script"]        duree_execution_change_query = dico_timestamp["begin_synergy_query"] - dico_timestamp["begin_change_query"]        duree_execution_synergy_query = dico_timestamp["end_synergy_query"] - dico_timestamp["begin_synergy_query"]        self.log("Temps d'exécution du script complet: {:d} seconds".format(duree_execution_script.seconds),gui_display=True)        self.log("Temps d'exécution de la requête Change: {:d} seconds".format(duree_execution_change_query.seconds),gui_display=True)        self.log("Temps d'exécution des requêtes Synergy: {:d} seconds".format(duree_execution_synergy_query.seconds),gui_display=True)        return True    def addRemark(self,remarks,item,localisation):        # Several remarks ?        tbl_remark = []        if remarks is not None:            #print "addRemark",remarks,localisation,item            if re.search(",",str(remarks)):                #print "REMARK SPLIT",remarks                tbl_remark = remarks.split(",")            else:                #print "REMARK",remarks                m = re.match(r'^([0-9]*)$',str(remarks))                if m:                    tbl_remark.append(int(remarks))            if item not in self.dico_remarks and tbl_remark != []:                # item is REQ REVIEW, REQ ANALYSIS or                # Localisation is requirement                self.dico_remarks[str(item),str(localisation)] = tbl_remark            else:                #print "ITEM:",remarks,item,localisation                self.dico_errors["remark","IS_5",localisation,remarks,item] = ["Remark identified here: rule {:s} does not exists in REMARK folder.".format(item)]                #print "la remarque existe ailleurs. On fait quoi ?"    def getRemarks(self,tbl_worksheet_cell,folder=False,dico_index={"item":0,"remark":5}):        """        Fill dictionary of remarks        :param tbl_worksheet_cell:        :param dico_index:        :param localisation:        :return:        """        #print "getRemark",tbl_worksheet_cell        if folder == "REVIEW" or folder == "DOC REVIEW":            for row in tbl_worksheet_cell:                item = row[dico_index["item"]]                localisation = ""                remarks = row[dico_index["remark"]]                self.addRemark(remarks,item,localisation)        else:            for row in tbl_worksheet_cell:                item = folder                localisation = row[dico_index["item"]]                remarks = row[dico_index["remark"]]                self.addRemark(remarks,item,localisation)    def checkISForSpec(self,                       filename_is="",                       dirname_req="",                       dirname_upper="",                       type=("SWRD",),                       skip_change_synergy_var=False,                       verif_issue_cr_process_start=2,                       component=""):        """        This function check Inspection Sheet document        First, the function "extract" is called to parse specification documents (ex: SwRD)        The result of extraction is in tbl_list_llr class attribute and set the flag spec_exists        Second of all the same function is called again to parse upper specification documents (ex: SSCS)        Then allocation is analysed and only upper requirements allocated to the selected component are kept.        :param filename_is:        :param dirname_req:        :param dirname_upper:        :param type:        :param skip_change_synergy_var:        :param verif_issue_cr_process_start:        :return:        """        self.nb_error = 0        self.dico_remarks = {}        self.dico_results = {"REVIEW":[],                             "DOC_REVIEW":[],                             "REQ_REVIEW":[],                             "REQ_ANALYSIS":[],                             "UPPER_REQ_ANALYSIS":[],                             "REMARKS":[]}        #self.is_list_reqs_in_review = []        #self.is_list_reqs_in_doc_review = []        #self.is_list_reqs_in_req_review = []        #self.is_list_reqs_in_req_analysis = []        #self.is_list_reqs_in_upper_req_analysis = []        # Launch clock        dico_timestamp={}        dico_timestamp["begin_script"] = datetime.now()        self.log(CheckIS.header("SPECIFICATION PARSING PART 1"),gui_display=True)        self.current_folder = "REQ ANALYSIS"        # Extract requirements from specification        print "dirname_req",dirname_req        if dirname_req != "":            self.extract(dirname_req,                         type)            self.spec_exists = True        else:            self.spec_exists = False        # Extract requirements from upper specifications.        print "dirname_upper",dirname_upper        if dirname_upper != "":            self.upper_exists = True            if type[0] in ("SWRD","PLDRD"):                hlr_selected = True                upper_type = self.getListUpper()            else:                hlr_selected = False                upper_type = ("SWRD",)            upper_type_str = "_".join(upper_type)            upper = CheckLLR(dirname_upper,                             hlr_selected=hlr_selected)            #upper.openLog(upper_type_str)            attr_check_filename,file_check_filename = upper.extract(dirname_upper,                                                                      type=upper_type,                                                                      component=component,                                                                      log_handler=self.log_handler)            #for file,reqs in upper.tbl_file_llr.iteritems():            #    print "FILE:",file            #    for req in reqs:            #        print "REQ:",req            # Filter upper requirements to keep only those allocated to the component selected.            upper.getAllocation()            print "upper.tbl_file_llr",upper.tbl_file_llr            if component != "" and component in upper.dico_alloc_vs_req:                nb_upper_req_found = 0                for file,reqs in upper.tbl_file_llr.iteritems():                    print "FILE:",file                    for req in reqs:                        if req in upper.dico_alloc_vs_req[component]:                            nb_upper_req_found += 1                print "Found {:d} upper requirements allocated to {:s}.".format(nb_upper_req_found,component)                nb_error = self.cmpList(self.list_upper_req,                                        upper.dico_alloc_vs_req[component],                                        "Specification document",                                        "Upper specification document")            else:                pass            doc_upper = upper.tbl_list_llr            print "doc_upper",doc_upper        else:            upper = CheckLLR()            self.upper_exists = False            doc_upper = None        self.log(CheckIS.header("LIST OF MODIFICATIONS"),gui_display=True)        # CONTEXT        self.current_folder = "CONTEXT"        self.log(CheckIS.header("CONTEXT"),gui_display=True)        # Le status de la cellule E6 et la somme des "Open Items Count"        # Pour chaque onglet on compte le nombre de cellules contenant un identifiant de remarque        dico_context = deepcopy(self.keywords)        print "checkISForSpec:filename_is",filename_is        extension = re.sub(r"(.*)\.(.*)",r"\2",filename_is)        if "xls" in extension:            self.resetSheetsList()            if extension in ("xlsx","xlsm"):                # data_only controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet.                try:                    wb = self.loadWorkbook(filename_is,data_only=True)                    self.parseContext(wb,dico_context)                    doc_inspected = self.checkContext(dico_context)                except pythoncom.com_error,e:                    wb = False                    doc_inspected = ("","")                    self.log(str(e),gui_display=True)                com = False            else:                try:                    excel = win32.gencache.EnsureDispatch('Excel.Application')                    wb = excel.Workbooks.Open(filename_is)                    doc_inspected = ("","")                    skip_change_synergy_var = True                except pythoncom.com_error,e:                    wb = False                    doc_inspected = ("","")                    print e                com = True            context_reference = str(doc_inspected[0])            context_issue = str(doc_inspected[1])            #for row,value  in dico_context.iteritems():            #    print "DICO_CONTEXT:",row,value            self.log("Document inspected has the reference {:s} and the version {:s}".format(context_reference,context_issue),gui_display=True)            self.log(CheckIS.header("SPECIFICATION PARSING PART 2"),gui_display=True)            release = str(self.is_release)            self.log("Modifications implemented in the release {:s}".format(release),gui_display=True)            for modif in self.tbl_dico_modifs:                # Display only the last modifications in the release of specification                context_version = CheckIS.getVersion(context_issue)                if "issue" in modif:                    modif_version = CheckIS.getVersion(modif["issue"])                    if context_version == modif_version:                        line = "Issue {:s}: {:s}".format(modif["issue"],Tool.removeNonAscii(modif["modif"]))                        self.log(line)            # Comparison of CR with Change database            dico_timestamp["begin_change_query"] = datetime.now()            dico_tableau_pr = {"all":[],                               "open":[],                               "closed":[]}            if not skip_change_synergy_var:                # get information for CR from Change database                # populate CR found in Change database                tbl_cr_change = []                ccb = CCB()                ccb.getPR(dico_tableau_pr,                          cr_with_parent = False,                          implemented_for = self.is_release,                          no_header=True)                for cr in dico_tableau_pr["all"]:                    cr_number = re.sub(r"([0-9]*)",r"\1",unicode(cr[0]))                    tbl_cr_change.append(cr_number)                self.list_cr_not_found = []                if tbl_cr_change != []:                    print "tbl_cr_change",tbl_cr_change                    print "tbl_is_cr_id",self.tbl_is_cr_id                    self.list_cr_not_found = self.cmpCR(tbl_cr_change,                                                        self.tbl_is_cr_id)            # Comparison of docs with Synergy database            dico_timestamp["begin_synergy_query"] = datetime.now()            if not skip_change_synergy_var:                list_projects = self._getProjectsList_wo_ihm(self.is_release,self.is_baseline)                #print "list_projects",list_projects                sub_list_rel_bas_proj = []                sub_list_projects = []                for project in list_projects:                    m = re.match(r'^CODE_(.*)',project)                    if not m:                        prj_name, prj_version = self.getProjectInfo(project)                        sub_list_projects_part = self.findSubProjects(prj_name,                                                                      prj_version,                                                                      sub_list_rel_bas_proj,                                                                      mute=False)                        #print "Synergy thread L1747:",sub_list_projects_part                        sub_list_projects.extend(sub_list_projects_part)                        #print "Synergy thread L1749:",sub_list_projects                sub_list_projects.extend(list_projects)                #print "sub_list_projects",sub_list_projects                list_synergy_docs = []                for project in sub_list_projects:                    match_code = re.match(r'^CODE_(.*)',project)                    match_plans = re.match(r'^SW_PLAN(.*)',project)                    if not match_code:                        # Exclude code source project                        if not match_plans:                            exclude=["Data sheet","CCB_MINUTES"]                            folder_to_search = "Input_Data"                        else:                            exclude=["CCB_MINUTES","SQAP","SDP"]                            folder_to_search = "SW_PLAN"                        self.log("Make Synergy query to get documents in project {:s} in \"{:s}\" folder".format(project,folder_to_search),gui_display=True)                        #print "project treated:",project                        list_synergy_docs_part = self.getItemsInFolder(folder_keyword = folder_to_search,                                                                  project=project,                                                                  baseline=self.is_baseline,                                                                  release=self.is_release,                                                                  exclude=exclude,                                                                  only_name=False,                                                                  with_extension=True,                                                                  mute=True)                        #print "list_synergy_docs",list_synergy_docs                        list_synergy_docs.extend(list_synergy_docs_part)                for docs in list_synergy_docs:                    m = re.match(r'^(IS|IP|CRI)(.*)',docs)                    if not m:                        # Exclude Inspection Sheets                        formatted_doc = re.sub(r'^(.*)_(ET|GS)([0-9]{4})(_[ES])?\.(.*) issue (.*)',r'\2\3/\6: \1 (\5)',docs)                        docs_ljust = formatted_doc.ljust(60)                        self.log("   Found input document {:s} for release {:s}".format(docs_ljust,self.is_release),gui_display=True)            dico_timestamp["end_synergy_query"] = datetime.now()            # get list input CRs            self.dico_results["CONTEXT"] = list(dico_tableau_pr["all"])            # REVIEW            self.current_folder = "REVIEW"            self.log(CheckIS.header("REVIEW"),gui_display=True)            list_general_rules = []            self.parseReview(wb,'A2:F50',1,list_general_rules,com)            #print "TEST_REVIEW:",list_general_rules            #exit()            nb_review_nok = self.checkStatus(list_general_rules,                                             context_issue)            self.getRemarks(list_general_rules,"REVIEW")            # DOC REVIEW            self.current_folder = "DOC REVIEW"            self.log(CheckIS.header("DOC REVIEW"),gui_display=True)            list_srs_rules = []            self.parseReview(wb,'A2:F200',2,list_srs_rules,com)            self.nb_error += self.checkRules(list_srs_rules,                                             type=type)            #print "list_srs_rules",list_srs_rules            #print "context_issue",context_issue            nb_doc_review_nok = self.checkStatus(list_srs_rules,                                                 context_issue)            self.getRemarks(list_srs_rules,"DOC REVIEW")            #exit(0)            #print "Remarks for DOC REVIEW",self.dico_remarks            # REQ REVIEW            self.current_folder = "REQ REVIEW"            self.log(CheckIS.header("REQ REVIEW"),gui_display=True)            is_list_reqs = []            self.parseReview(wb,'A3:BS10000',3,is_list_reqs,com)            # Check coherency between requirement list in IS an requirement in specification document            self.tbl_reqs_updated = self.checkReq(is_list_reqs)            self.log("Nb requirements updated for this release according to REQ REVIEW folder: {:d}.".format(len(self.tbl_reqs_updated)),gui_display=True)            for req in self.tbl_reqs_updated:                self.log("   " + req)            # Check specific for DOC REVIEW: Need to sweep all rules ...            # Get rules            is_list_srs_res_rules = []            self.parseReview(wb,'F1:BS1',3,is_list_srs_res_rules,com)            if is_list_srs_res_rules != []:                tbl_srs_req_rules = self.checkReqRules(is_list_srs_res_rules[0])                nb_req_review_nok = self.checkStatusReqReview(is_list_reqs,                                                              tbl_srs_req_rules,                                                              type=type)            else:                tbl_srs_req_rules = []                nb_req_review_nok = 0            self.dico_results["REQ_REVIEW"] = list(is_list_reqs)            # REQ ANALYSIS (§6.3.1a of DO-178B: Compliance with system requirements)            # SwRD Requirement.: SwRD requirement (except DELETED)            # Requirement Issue: SwRD requirement issue            # REQ ANALYSIS:            #  o NOK if SwRD. requirement does not comply with one or more linked Equip./Syst. Req or Derived SwRD is not correctly justified.            #  o NOT VERIFIED if SwRD requirement is not verified,            #  o OK if SwRD requirement complies with all linked Equip./Syst.req or Derived SwRD is correctly justified.            # Reviewers: list of reviewer’s names on the last reviewed document issue for the item’s objective.            # Reviewed Requirement Issue: the last reviewed requirement issue for the item.            # Remarks: list of remarks number logged in the “REMARKS” sheet if the remarks are still presents in the current context.            self.log(CheckIS.header("REQ ANALYSIS"),gui_display=True)            self.current_folder = "REQ ANALYSIS"            #header = [u'SwRD Req.', u'Req. Issue', u'REQ_ANALYSIS', u'Reviewers', u'Req. Issue', u'Remarks']            del(is_list_reqs[:])            self.parseReview(wb,'A3:F10000',4,is_list_reqs,com)            # Check coherency between requirement list in IS and requirement in specification document            #print "spec_exists:",self.spec_exists            if self.spec_exists:                #print " if self.spec_exists:is_list_reqs",is_list_reqs                tbl_reqs_updated = self.checkReq(is_list_reqs,True)            # Check status            nb_req_analysis_nok = self.checkStatus(is_list_reqs)            self.getRemarks(is_list_reqs,"REQ ANALYSIS")            # store list of requirements            self.dico_results["REQ_ANALYSIS"] = list(is_list_reqs)            #for x in is_list_reqs:            #    print "IS req",x            #self.log("Nb requirements updated for this release according to REQ ANALYSIS folder: {:d}".format(len(tbl_reqs_updated)))            self.log(CheckIS.header("UPPER REQ ANALYSIS"))            self.current_folder = "UPPER REQ ANALYSIS"            # UPPER REQ ANALYSIS: (§6.3.1f of DO-178B: Traceability -> the requirements of the system are developed into the high-level requirements.            del(is_list_reqs[:])            self.parseReview(wb,'A3:F10000',5,is_list_reqs,com)            # Check coherency with specification (Refers to)            list_upper_req = []            nb_upper_reqs = self.getUpperReqList(list_upper_req)            if nb_upper_reqs == 0:                list_upper_req = None            #nb_upper_reqs = len(list_upper_req)            if self.upper_exists:                #                # Call checkUpperReq which deals with IS_8, IS_19 and IS_20 rule tag                #                #print "TEST2",doc_upper                self.checkUpperReq(is_list_reqs,        # is_list_reqs contains list of upper requirements extracted from IS                                   list_upper_req,      # list_upper_req contains list of upper requirements extracted from "Refers to" specification (ex: SWRD)                                   doc_upper)           # doc_upper contains list of upper requirements extracted from specification (ex: SSCS)            # Check status            #            # Call checkStatus which call detectError which deals with IS_1, IS_2 and IS_3 rule tag            #            nb_upper_req_analysis_nok = self.checkStatus(is_list_reqs)            self.dico_results["UPPER_REQ_ANALYSIS"] = list(is_list_reqs)            self.getRemarks(is_list_reqs,"UPPER REQ ANALYSIS")            # Check reader            dico_readers,effort_total = self.checkReviewers(is_list_reqs)            if nb_upper_reqs != 0:                for reader,effort in dico_readers.iteritems():                    pourcentage = effort * 100 / nb_upper_reqs                    self.log("{:s} reading effort: {:d}%".format(reader,pourcentage))            self.log(CheckIS.header("REMARKS"),gui_display=True)            self.current_folder = "REMARKS"            # REMARKS            #            # - Check numbering of remarks is an unbroken sequence            # - Check remarks opened            #            #print "Remarks for REQ REVIEW"            tbl_remarks_other_folders = []            nb_remarks_infolder = self.getRemarkInOverfolders(tbl_remarks_other_folders)            #for value in  self.dico_remarks.values():            #    list_remarks_other_folders.append(value)                #"print "DICO_REMARK;",loc,item,value            list_remarks = []            self.parseReview(wb,'A2:K10000',6,list_remarks,com)            self.nb_remarks = len(list_remarks)            list_remarks_open = []            self.list_cr =[]            self.nb_remarks_open = self.checkRemarks(list_remarks,                                                self.list_cr,                                                verif_issue_cr_process_start,                                                list_remarks_open)            self.dico_results["REMARKS"] = list(list_remarks)            #print "Nb remaks open:",nb_remarks_open            print "cmpList arg 1:",tbl_remarks_other_folders            print "cmpList arg 2 list_remarks_open:",list_remarks_open            #print "tbl_list_llr",self.tbl_list_llr            self.nb_error += self.cmpList(tbl_remarks_other_folders,                                          list_remarks_open, # list open remarks coming from checkRemarks                                          cmp_one="REMARK folder (OPEN)",                                          cmp_two="any other folder")            if not skip_change_synergy_var:                self.log(CheckIS.header("Check CR is software related"),gui_display=True)                # Test if CR are software related:                dico_cr = {}                for cr in self.list_cr:                    #print "CR:",cr                    self.getCRInfo(cr,                                   dico_cr,                                   parent=False)                for cr_id,value in dico_cr.iteritems():                    type = value[0]                    if value[0] != "SCR":                        self.logWarning("IS_25",cr_id,type)            self.log("Found {:d} remarks in other folders than REMARK.".format(nb_remarks_infolder),gui_display=True)            self.log("Found {:d} remarks OPEN in folder REMARK.".format(self.nb_remarks_open),gui_display=True)            if nb_remarks_infolder != self.nb_remarks_open:                self.nb_error += 1            #print ws.columns            #sheet_ranges = wb['CONTEXT']            #print(sheet_ranges['E6'].value)            self.log("{:d} errors found.".format(len(self.dico_errors)),gui_display=True)            self.log("{:d} warnings found.".format(len(self.dico_warnings)),gui_display=True)            self.log("{:d} cells read.".format(self.nb_cell_read),gui_display=True)            self.log("In REVIEW sheet, {:d} errors found.".format(nb_review_nok),gui_display=True)            self.log("In DOC REVIEW sheet, {:d} errors found.".format(nb_doc_review_nok),gui_display=True)            self.log("In REQ REVIEW sheet, {:d} requirements not OK.".format(nb_req_review_nok),gui_display=True)            self.log("In REQ ANALYSIS sheet, {:d} requirements not OK.".format(nb_req_analysis_nok),gui_display=True)            self.log("In UPPER REQ ANALYSIS sheet, {:d} requirements not OK.".format(nb_upper_req_analysis_nok),gui_display=True)            self.log("In REMARKS sheet, {:d} remarks OPEN.".format(self.nb_remarks_open),gui_display=True)            dico_timestamp["end_script"] = datetime.now()            duree_execution_script = dico_timestamp["end_script"] - dico_timestamp["begin_script"]            duree_execution_change_query = dico_timestamp["begin_synergy_query"] - dico_timestamp["begin_change_query"]            duree_execution_synergy_query = dico_timestamp["end_synergy_query"] - dico_timestamp["begin_synergy_query"]            self.log("Temps d'exécution du script complet: {:d} seconds".format(duree_execution_script.seconds),gui_display=True)            self.log("Temps d'exécution de la requête Change: {:d} seconds".format(duree_execution_change_query.seconds),gui_display=True)            self.log("Temps d'exécution des requêtes Synergy: {:d} seconds".format(duree_execution_synergy_query.seconds),gui_display=True)            filename_is_short = self.extractName(filename_is)        else:            # Wrong Word format, only openxml            text = "Wrong Excel format for {:s}, only openxml format (xlsx/xlsm) accepted".format(filename_is)            self.log(text)            doc_inspected = ("None","None")            filename_is_short = ""        return upper.tbl_file_llr,doc_inspected,filename_is_short,attr_check_filename,file_check_filename    def getValue(self,                 deepcopy_keywords,                 key,                 tag,                 value,                 label=None):        for sub_tag,offset in self.keywords[key].iteritems():            if isinstance(offset,int) and self.index_row == (tag["row"] + offset) and self.index_column == (tag["column"] + 1):                #print "tag:",tag                #print "getValue:",key,tag,label,sub_tag,offset                #print "offset",offset                if label is not None:                    deepcopy_keywords[key][label] = value                else:                    deepcopy_keywords[key][sub_tag] = value            self.nb_cell_read += 1    def fillDico(self,key,word="DOC"):        for x in range(1,30):            str = "{:s}_{:d}".format(word,x)            self.keywords[key][str] = x    def parseReview(self,                    wb,                    range='A1:F50',                    sheet_no=1,                    review_tbl = [],                    com = False):        """        Update_ReqStatus        REQ ANALYSIS (SVP §4.2.5.2.2 SwRD Analysis)            Si la version de l'exigence dans la colonne "Requirement Issue"            est inférieure à la version revue dans la colonne "Reviewed Req. Issue"            et que la colonne "Remark" est vide            alors la fonction renvoie "OK" sinon elle renvoie "NOK" dans le cas où des remarques existent.            Si la version revue dans la colonne "Reviewed Req. Issue"            est inférieure à la version de l'exigence dans la colonne "Requirement Issue" ou que la colonne "Reviewers" est vide            alors la fonction renvoie "NOT VERIFIED"        REQ REVIEW (SVP §4.2.4.8 SwRD Review)            Même principe que pour REQ ANALYSIS sauf que la fonction boucle sur toutes les règles.            Si une des règles est "NOT VERIFIED" alors la fonction renvoie:                - PARTIALLY VERIFIED (NOK): Une des règles n'est pas vérifiée et une remarque au moins existe                - PARTIALLY VERIFIED (OK): Une des règles n'est pas vérifiée et aucune remarque n'est enregistrée        GetReviewerNames            Cette fonction, utilisée dans l'onglet REQ REVIEW, permet de concaténer tous les noms des relecteurs par règle            à condition que l'auteur est vérifié la règle pour la version courante de l'exigence.        Concatener_ReqRemarks            Cette fonction, utilisée dans l'onglet REQ REVIEW, permet de concaténer toutes les remarques par règle            quelque soit la version de l'exigence revue        :param wb:        :param range:        :param sheet_no:        :return:        """        #        # Column "Status" in REVIEW, DOC_REVIEW and REQ REVIEW sheet is filled automatically with the formula:        # Update_ReqStatus(D2:F2,F2,Issue)        #        # Column "Remarks" in REQ REVIEW sheet is filled automatically with the formula:        # Concatener_ReqRemarks(F679:BS679)        #        # Column "Reviewers" in REQ REVIEW sheet is filled automatically with the formula:        # GetReviewerNames(F679:BS679,B679)        #        # Column "REQ_ANALYSIS" in REQ ANALYSIS sheet is filled automatically with the formula:        # Update_ReqStatus(D3:F3,F3,B3)        #        def getRows(ws,range,com):            if com:                #print "TEST1",ws                #print "TEST2",range                #print "TEST3",ws.Range(range).Value                result = ws.Range(range).Value            else:                result = ws.iter_rows(range)            return result        if wb:            if com:                #print "TEST0",sheet_no                ws = wb.Worksheets(sheet_no)            else:                ws = wb.get_sheet_by_name(name = self.sheets_list[sheet_no]) # ws is now an IterableWorksheet            if ws is not None:                nb_rows = 0                for row in getRows(ws,range,com): # it brings a new method: iter_rows()                    self.index_row += 1                    # New line                    row_tbl = []                    self.index_column = 0                    row_empty = True                    for cell in row:                        self.index_column += 1                        if not com:                            row_tbl.append(cell.value)                            if Tool.isAttributeValid(cell.value):                                row_empty = False                        else:                            row_tbl.append(cell)                            if Tool.isAttributeValid(cell):                                row_empty = False                        self.nb_cell_read += 1                        #if self.nb_cell_read > 65530:                        #    print self.nb_cell_read                    if not row_empty:                        nb_rows += 1                        review_tbl.append(row_tbl)                print "nb_rows",sheet_no,nb_rows    def cmpDocs(self,expected,found):        union = list(set(expected) & set(found))        exclusion = list(set(expected) ^ set(found))        len_union = len(union)        len_found = len(found)        if len_union == len_found and exclusion == []:            match = True        elif len_union < len_found:            match = False            #self.nb_error += 1            for req in exclusion:                self.logError(rule_tag="IS_27",rule_id=req,additional=self.is_release)                #self.logErrors()                #self.log("Warning: Documents {:s} found in Inspection Sheet but not in Synergy for release {:s}".format(req,self.is_release),True)                #self.nb_error += 1        else:            match = False            self.nb_error += 1            print "Unexpected items",exclusion        return match    def cmpCR(self,              expected,              found):        union = list(set(expected) & set(found))        exclusion = list(set(expected) ^ set(found))        len_union = len(union)        len_found = len(found)        if len_union == len_found and exclusion == []:            match = True        elif len_union < len_found:            match = False            self.nb_error += 1            print "exclusion",exclusion            print "union",union            for req in exclusion:                self.logError(rule_tag="IS_26",rule_id=req,additional=self.is_release)                #self.log("Warning: CR {:s} found in Inspection Sheet but not in Change for release {:s}".format(req,self.is_release),True)                #self.nb_error += 1        else:            match = False            self.nb_error += 1            print "Unexpected CRs",exclusion        return exclusion    def checkContext(self,dico_context):        self.tbl_cr = []        self.tbl_is_cr_id = []        doc_inspected = {}        project_info = {}        applicable_docs = {}        for part,y in dico_context.iteritems():            for tag,content in y.iteritems():                if not re.match(r'^EMPTY.*',tag):                    if part == "docs":                        self.applicable_docs[tag]= content                    elif part == "gen":                        project_info[tag]= content                        if tag == "Project Release":                            self.is_release = content                    elif part == "ids":                        doc_inspected[tag]= content                        if tag == "Verification baseline":                            self.is_baseline = content                    elif part == "crs":                        #print "TEST_TAG",tag                        cr_id = re.sub(r'.*CR ?([0-9]*)',r'\1',tag)                        if content is None:                            content = "None"                        self.tbl_cr.append((cr_id,content))                        #print "CR_ID:",cr_id                        self.tbl_is_cr_id.append(cr_id)                    #print "{:s} => {:s}->{:s}->{:s}".format(self.current_folder,part,tag,content)        nb_crs = len(self.tbl_cr)        self.log("Found {:d} change requests".format(nb_crs),gui_display=True)        if nb_crs > 0:            self.tbl_cr.sort()            for cr,synopsis in self.tbl_cr:                self.log("   {:s}: {:s}".format(cr,synopsis),gui_display=True)        nb_applicable_docs = len(self.applicable_docs)        self.log("Found {:d} applicable documents".format(nb_applicable_docs),gui_display=True)        if nb_applicable_docs > 0:            for title,reference in self.applicable_docs.iteritems():                self.log("   {:s}: {:s}".format(reference,title),gui_display=True)        self.log("Release: {}".format(self.is_release))        self.log("Baseline: {}".format(self.is_baseline))        self.context_issue = doc_inspected["Issue"]        return doc_inspected["Reference"],doc_inspected["Issue"]    def checkReqRules(self,list_srs_res_rules):        tbl_srs_req_rules = []        nb_expected_srs_req_rules = len(self.expected_srs_req_rules_dico)        for rule in list_srs_res_rules:            if rule is not None:                tbl_srs_req_rules.append(rule)        nb_found_srs_req_rules = len(tbl_srs_req_rules)        if nb_found_srs_req_rules != nb_expected_srs_req_rules:            self.log( "Warning: Found {:d} SRS_REQ rules instead of {:d} expected.".format(nb_found_srs_req_rules,nb_expected_srs_req_rules),True)        return tbl_srs_req_rules    def checkRules(self,                   list_srs_rules,                   type=("SWRD",)):        """        Function specific for requirements specification check        :param list_srs_rules:        :return:        """        # Liste des règles SRTS        if "SWRD" in type:            list_rules = self.expected_srs_rules        elif "SWDD" in type:            list_rules = self.expected_sds_rules        nb_expected_srs_rules = len(list_rules)        nb_found_srs_rules = len(list_srs_rules)        if nb_found_srs_rules != nb_expected_srs_rules:            print "list_rules",list_rules            print "list_srs_rules",list_srs_rules            self.dico_errors["ERROR","IS_6","REQ REVIEW","",""] = ["Found {:d} SRS_REQ rules instead of {:d} expected.".format(nb_found_srs_rules,nb_expected_srs_rules)]            #self.log( "Warning: Found {:d} SRS_REQ rules instead of {:d} expected.".format(nb_found_srs_rules,self.nb_expected_srs_rules),True)        found_srs_rules = []        for srs_rule in list_srs_rules:            found_srs_rules.append(srs_rule[0])        nb_errors = self.cmpList(list_rules,                                 found_srs_rules,                                 cmp_two="SDTS standard",                                 cmp_one="Inspection Sheet")        #print "match:",match        return nb_errors    def checkUpperReq(self,                      is_list_reqs,                       # IS                      upper_list_req=None,                # Refers to in main spec                      upper_list_req_from_upper=None):    # Upper spec        """        Compare amount of upper requirements with IS        Compare reviewed issue with requirement issue        :param is_list_reqs: contains list of upper requirements extracted from IS        :param upper_list_req: contains list of upper requirements extracted from "Refers to" specification        :param upper_list_req_from_upper: contains upper requirements coming form specification document per document                                        ex: SSCS_ACLog_790 {'status': u'MATURE', etc.        :return:        """        nb_reqs = len(is_list_reqs)        found_reqs = []        is_list_reqs_w_issue = []        for req in is_list_reqs:            # look requirements in IS            found_reqs.append(req[0])            is_list_reqs_w_issue.append((req[0],    # Req ID                                         req[1],    # Requirement issue                                         req[3],    # Reviewer                                         req[4],    # Reviewed issue                                         req[5]     # Remarks            ))        if upper_list_req is not None:            # Check coherency between requirement list in IS an requirement refers to in specification document            nb_reqs_in_doc = len(upper_list_req)            if nb_reqs != nb_reqs_in_doc:                self.log( "Warning: Found {:d} upper requirement in Inspection Sheet instead of {:d} expected from refers to in specification document.".format(nb_reqs,nb_reqs_in_doc),True)            self.nb_error += self.cmpList(upper_list_req,                                          found_reqs)        if upper_list_req_from_upper is not None:            # Check coherency between requirement list in IS an requirement in upper specification document            nb_reqs_in_doc = len(upper_list_req_from_upper)            if nb_reqs != nb_reqs_in_doc:                self.log( "Warning: Found {:d} upper requirement in Inspection Sheet instead of {:d} expected from specification document.".format(nb_reqs,nb_reqs_in_doc),True)            print "ZER",upper_list_req_from_upper            self.nb_error += self.cmpList(upper_list_req_from_upper,                                          found_reqs,upper=True)        #print "upper_list_req",upper_list_req        #print "found_reqs",found_reqs        tbl_reqs_updated = []        for req,is_issue,reviewer,is_reviewed_issue,remarks in is_list_reqs_w_issue:            # Display requirements candidates for re-inspection and status of inspection            #version_context = getVersion(context_issue)            # In excel file sometimes numbers are integers and sometimes strings            #print "is_issue brute:",is_issue            is_issue_str = Tool.removeBlankSpace(str(is_issue))            is_reviewed_issue_str = Tool.removeBlankSpace(str(is_reviewed_issue))            version_is = CheckIS.getVersion(is_issue_str)            version_reviewed_is = CheckIS.getVersion(is_reviewed_issue)            #if version_context == version_is:            #    tbl_reqs_updated.append(req)            # Get differences            error = self.detectError(req,                                     is_reviewed_issue_str,                                     is_issue_str,                                     remarks,                                     reviewer                                     )            if error:                self.nb_error += 1            #if is_issue_str != is_reviewed_issue_str:            #    self.nb_error += 1            #    self.dico_errors["consistency","IS_8",self.current_folder,req,""] = ["For {:s} issue is {:s} in 'Review issue' column whereas issue is {:s} in 'Req. Issue' column.".format(req,is_issue_str,is_reviewed_issue_str)]            # Compare with issue in upper specification            #print "upper_list_req_from_upper",upper_list_req_from_upper            upper_issue = self.getIssue(req,                                        upper_list_req_from_upper)            if upper_issue != "Unknown":                upper_issue_str = str(upper_issue)                if upper_issue_str != is_issue_str:                    self.nb_error += 1                    self.dico_errors["ERROR","IS_19",self.current_folder,req,""] = ["For {:s} issue is {:s} in 'Review issue' column whereas issue is {:s} in upper specification.".format(req,is_issue_str,upper_issue_str)]            else:                    #self.nb_error += 1                    self.logWarning("IS_20",req,"")                    #self.dico_warning["WARNING","IS_20",self.current_folder,req,""] = ["Requirement {:s} is not included in upper specification.".format(req)]    @staticmethod    def getVersion(issue):        if type(issue) is str:            version = re.sub(r"(.*)\.(.*)", r"\1", str(issue))        else:            version = str(issue)        return version    @staticmethod    def getVersionRevision(issue):        if type(issue) is str:            version = re.sub(r"(.*)\.(.*)", r"\1", str(issue))            revision = re.sub(r"(.*)\.(.*)", r"\2", str(issue))        else:            version = str(issue)            revision = ""        return version,revision    @staticmethod    def compareVersionRevision(input1,input2):        version1,revision1 = CheckIS.getVersionRevision(input1)        version2,revision2 = CheckIS.getVersionRevision(input2)        status = None        if version1.isdigit() and version2.isdigit() and revision1.isdigit() and revision2.isdigit():            if int(version1) < int(version2):                status = "INF"            elif int(version1) > int(version2):                status = "SUP"            else:                if int(revision1) < int(revision2):                    status = "INF"                elif int(revision1) > int(revision2):                    status = "SUP"                else:                    status = "EQUAL"        return status    @staticmethod    def removeSpaceBefore(input):        if type(input) is str:            output = re.sub(r"^\s*(\w*)", r"\1",input)        else:            output = str(input)        return output    def checkReq(self,                 is_list_reqs,                 check_issue_in_xls=False):        #print "Test_checkReq: is_list_reqs",is_list_reqs        def removeSpaceBefore(input):            if type(input) is str:                output = re.sub(r"^\s*(\w*)", r"\1",input)            else:                output = str(input)            return output        nb_reqs = len(is_list_reqs)        #print "{:d} requirements found in IS REQ REVIEW sheet:".format(nb_reqs)        found_reqs = []        is_list_reqs_w_issue = []        print 'nb_reqs',nb_reqs        nb_problem = 0        for req in is_list_reqs:            # Remove blank space before            if req[0] is not None:                req_id = removeSpaceBefore(req[0])            else:                nb_problem += 1                req_id = ""            #print "REQ_ID:",req[0],req_id            found_reqs.append(req_id)            is_list_reqs_w_issue.append((req_id,req[1],req[4]))        #print 'nb_found_reqs',len(found_reqs)        #print "found_reqs",found_reqs        #print "nb problem",nb_problem        # Check coherency between requirement list in IS an requirement in specification document        list_all_reqs = []        for doc_name,reqs_in_doc in self.tbl_file_llr_wo_del.iteritems(): # exclude deleted requirements            #print "REQ:",doc_name,reqs_in_doc            list_all_reqs.extend(reqs_in_doc)            nb_reqs_in_doc = len(reqs_in_doc)            self.log("{:d} requirements found in specification document {:s}:".format(nb_reqs_in_doc,doc_name))        self.nb_error += self.cmpList(list_all_reqs, # Requirements in specification expect DELETED                                      found_reqs,   # Requirements in IS excel file                                      cmp_one="Specification document",                                      cmp_two="Inspection Sheet"                                    )        tbl_reqs_updated = []        for req,is_issue,is_reviewed_issue in is_list_reqs_w_issue:            #print "DEBUG",is_list_reqs_w_issue            # Display requirements candidates for re-inspection and status of inspection            #version_context = Tool.removeBlankSpace(CheckIS.getVersion(self.context_issue))            #version_is = Tool.removeBlankSpace(CheckIS.getVersion(is_issue))            version_context = Tool.removeBlankSpace(self.context_issue)            version_is = Tool.removeBlankSpace(is_issue)            version_reviewed_is = Tool.removeBlankSpace(CheckIS.getVersion(is_reviewed_issue))            if version_context == version_is:                #print "if version_context == version_is |{:s}|{:s}|".format(version_context,version_is)                tbl_reqs_updated.append(req)            else:                pass                #print "if version_context == version_is |{:s}|{:s}|".format(version_context,version_is)            # Get differences            if req in self.tbl_list_llr:                value = self.tbl_list_llr[req]                spec_issue = removeSpaceBefore(CheckLLR.getAtribute(value,"issue"))                spec_issue_regex = removeSpaceBefore(self.cleanIssue(spec_issue))                is_issue_regex = removeSpaceBefore(self.cleanIssue(is_issue))                if spec_issue_regex != is_issue_regex:                    #print "if spec_issue_regex != is_issue_regex |{:s}|{:s}|".format(spec_issue_regex,is_issue_regex)                    self.nb_error += 1                    self.dico_errors["ERROR","IS_9",self.current_folder,req,""] = ["For {:s} issue is {:s} in specification document and {:s} in Inspection Sheet.".format(req,spec_issue_regex,is_issue_regex)]                elif check_issue_in_xls and Tool.removeBlankSpace(is_issue) != Tool.removeBlankSpace(is_reviewed_issue):                    self.nb_error += 1                    self.dico_errors["ERROR","IS_10",self.current_folder,req,""] = ["For {:s} issue is {:s} in 'Review issue' column and {:s} in 'Req. Issue' column.".format(req,version_is,version_reviewed_is)]        return tbl_reqs_updated    @staticmethod    def cleanIssue(number):        if type(number) is str:            number_regex = re.sub(r'([0-9]*)\.([0-9]*)',r'\1.\2',number)        else:            number_regex = str(number)        return number_regex    def checkRemarks(self,                     list_remarks,                     list_cr=[],                     verif_issue_cr_process_start=2,                     list_remarks_folder=[]):        """        Check remarks        :param list_remarks: INPUT list of remarks extracted from Excel workbook        :param list_cr: OUTPUT List of CR found in list_remarks        :param verif_issue_cr_process_start: INPUT        :param list_remarks_folder: OUTPUT        :return:        """        index = 1        nb_remarks_open = 0        # ID, remark, localisation, author's remark, item, origin, analysis, status, cr, verification        for remarks in list_remarks:            if remarks[0] is not None and remarks[1] is not None:                # ID and Remark field is not null                try:                    id = int(remarks[0])                    remark_id = "Remark {:d}".format(id)                except ValueError,e:                    print e                    id = 0                    remark_id = "Remark {}".format(remarks[0])                remark_status = remarks[7]                # Localisation in document                localisation = remarks[2]                # Item                item = remarks[4]                if id != index:                    self.logWarning("IS_11",remark_id,index)                    index = id                index += 1                status = remarks[7]                cr = remarks[8]                origin_issue = self.removeSpaceBefore(remarks[5])                verif_issue = self.removeSpaceBefore(remarks[9])                if cr is not None:                    # Test if CR match a number only                    test_cr = re.match(r'([^0-9]*)([0-9]{1,4})',str(cr))                    if test_cr:                        # Yes it is                        cr = test_cr.group(2)                        if cr not in list_cr:                            list_cr.append(cr)                else:                    # Check if CR process was entered                    try:                        origin_version = int(CheckIS.getVersion(origin_issue))                    except ValueError:                        self.logWarning("IS_12",remark_id,"")                    if origin_version < verif_issue_cr_process_start:                        # CR process is not yet started for this document                        test_cr = True                    elif origin_version == verif_issue_cr_process_start and remark_status != "REJECTED":                        self.logWarning("IS_13",remark_id,"")                        test_cr = True                    else:                        test_cr = False               # print "REMARK ID:",id                #if id == 1295:                #    print "Info|{}|{}|{}|".format(test_cr,origin_issue,verif_issue)                # Check remark status                result_comp_verif_origin = self.compareVersionRevision(verif_issue,origin_issue)                #print "TEST:",verif_issue,origin_issue,result_comp_verif_origin                if (status == "REJECTED" and (verif_issue == "" or verif_issue in (None,"None"))):                    self.logWarning("IS_27",remark_id,"")                    nb_remarks_open += 1                    list_remarks_folder.append(id)                elif (status == "CORRECTED" and result_comp_verif_origin is "SUP" and test_cr) or \                        (status == "REJECTED" and  result_comp_verif_origin is not "INF"):                    # Status is CORRECTED and issue verified is greater than issue including the defect.                    # Status is REJECTED and issue verified is greater than or equal to the issue when the remark was raised.                    # CR process is not yet started for this document or a CR is missing                    # No problem, remark is closed.                    pass                elif (status == "CORRECTED" and result_comp_verif_origin is not "SUP" and test_cr):                    print "{:s} - if verif_issue <= origin_issue |{:s}|{:s}|".format(remark_id,verif_issue,origin_issue)                    # Status is CORRECTED and issue verified is lower than or equal to the issue including the defect.                    # CR process is not yet started for this document or a CR is missing                    # Remark is still open.                    nb_remarks_open += 1                    list_remarks_folder.append(id)                    if verif_issue == "":                        # Remark corrected but not verified                        self.logWarning("IS_14",remark_id,"")                elif status == "TO BE DISCUSSED":                    self.logWarning("IS_23",remark_id,"")                    nb_remarks_open += 1                    list_remarks_folder.append(id)                elif not test_cr:                    # ACCEPTED or REJECTED                    print "IS_15:",status,verif_issue                    # CR cell not valid (expecting a number)                    self.logWarning("IS_15",remark_id,"")                    nb_remarks_open += 1                    list_remarks_folder.append(id)                else:                    print "STATUS",status                    print "{:s} - verif_issue - origin_issue |{:s}|{:s}|".format(remark_id,verif_issue,origin_issue)                    self.logWarning("IS_16",remark_id,"")                    nb_remarks_open += 1                    list_remarks_folder.append(id)                    # Check remark NOK which should appear in other worksheets                    try:                        if localisation is not None:                            localisation = str(Tool.replaceNonASCII(localisation))                            item = re.sub(r'_',r' ',str(item))                            if (item,localisation) in self.dico_remarks:                                dico_remark_line = self.dico_remarks[(item,localisation)]                                if id not in dico_remark_line:                                    self.logWarning("IS_26",id,(item,localisation))                                    #self.log("Warning: {:s} => Remark {:d} is not seen in localisation {:s} with item {:s}".format(self.current_folder,id,localisation,item),True)                        else:                            localisation = ""                    except KeyError,e:                        print e                        self.log("Warning: {:s} => Remark {:d} is not seen in localisation {:s} with item {:s}".format(self.current_folder,id,localisation,item),True)                    except UnicodeEncodeError,e:                        print e                        print "Warning: {:s} => Remark {:d} used non ASCII character".format(self.current_folder,id)                    except TypeError,e:                        print e                        print "Warning: {:s} => Remark {:d} used weird character".format(self.current_folder,id)                        print "LOCALISATION",localisation        return nb_remarks_open    @staticmethod    def header(text):        if 0==1:            length = len(text)            line_tbl = []            for x in range(length + 4):                line_tbl.append("*")            line_str = "".join(line_tbl)            return line_str + "\n* " + text +" *\n" + line_str        header = "### {:s} ###".format(text)        return header    @staticmethod    def headerNice(text):        length = len(text)        line_tbl_top = []        line_tbl_bottom = []        line_tbl_top.append("É")        line_tbl_bottom.append("È")        for x in range(length + 4):            line_tbl_top.append("Í")            line_tbl_bottom.append("Í")        line_tbl_top.append("»")        line_tbl_bottom.append("¼")        line_top_str = "".join(line_tbl_top)        line_bottom_str = "".join(line_tbl_bottom)        return line_top_str + "\nº " + text +" º\n" + line_bottom_str    def logError(self,                 rule_tag="",                 rule_id="",                 additional=""):        """        :param rule_tag: Ex: "IS_25"        :param rule_id: Ex: ""        :param additional:        :return:        """        if rule_tag == "IS_2":            self.dico_errors["ERROR",rule_tag,self.current_folder,rule_id,additional] =\                ["Verified version does not exist (verified issue is greater than requirement/document issue)."]        elif rule_tag == "IS_26":            self.dico_errors["ERROR",rule_tag,self.current_folder,rule_id,additional] =\                ["CR {:s} found in Inspection Sheet but not in Change for release {:s}".format(rule_id,additional)]        elif rule_tag == "IS_26":            self.dico_errors["ERROR",rule_tag,self.current_folder,rule_id,additional] =\                ["Document {:s} found in Inspection Sheet but not in Synergy for release {:s}".format(rule_id,additional)]        elif rule_tag == "IS_31":            self.dico_errors["ERROR",rule_tag,self.current_folder,rule_id,additional] =\                ["Rule {:s} unknown.".format(additional)]        else:            print "Unknown error"            raise ValueError("Unknown error")        self.nb_error += 1    def logWarning(self,rule_tag="",rule_id="",additional=""):        if rule_tag == "IS_1":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,additional] =\                ["Status is NOT VERIFIED (verified issue is lesser than requirement/document issue or verified issue is empty)."]        elif rule_tag == "IS_3":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,additional] =\                ["Status is NOK (A remark exists)."]        elif rule_tag == "IS_11":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["Remark ID should be {:s} instead of {:d}.".format(rule_id,additional)]        elif rule_tag == "IS_12":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["Invalid verification issue for remark."]        elif rule_tag == "IS_13":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["No CR has been submitted whereas the CR process has already started."]        elif rule_tag == "IS_14":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["Verification issue is equal or lower than document issue including the defect."]        elif rule_tag == "IS_27":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["Missing Verification issue."]        elif rule_tag == "IS_15":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \               ["Remark {:s} is KO because CR cell is not valid (4.2.3 of SVP).".format(str(rule_id))]        elif rule_tag == "IS_16":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \               ["Remark OPEN."]        elif rule_tag == "IS_23":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["Status TO BE DISCUSSED not allowed at this stage of peer review process."]        elif rule_tag == "IS_20":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["Requirement {:s} is not included in upper specification.".format(rule_id)]        elif rule_tag == "IS_25":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["CR {:s} is a {:s} and should be a SCR instead.".format(rule_id,additional)]        elif rule_tag == "IS_28":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["Remark {:d} is not seen in localisation {:s} with item {:s}".format(rule_id,additional[1],additional[0])]        elif rule_tag == "IS_26":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,""] = \                ["Remark {:d} is not seen in localisation {:s} with item {:s}".format(rule_id,additional[1],additional[0])]        elif rule_tag == "IS_30":            self.dico_warnings["WARNING",rule_tag,self.current_folder,rule_id,additional] =\                ["Rule {:s} not verified.".format(rule_id)]        elif rule_tag == "IS_24":            self.dico_warnings["ERROR",rule_tag,self.current_folder,rule_id,additional] = ["Rule not applicable for a requirement deleted."]        else:            print "Unknown error"            raise ValueError("Unknown error")        self.nb_warning += 1    def detectError(self,                    rule_id,                    document_issue, # version of requirement/document reviewed                    req_issue,      # Issue from context                    remarks,                    reviewer,                    type="Rule"):        #print "TOTO:",document_issue,remarks,reviewer        if document_issue in (None,"None") and remarks in (None,"None") and reviewer in (None,"None"):            # review not performed            self.logWarning("IS_30",rule_id,"")        elif document_issue == req_issue and \                        remarks is None and \                        reviewer is not None:            # print "Rule {:s} is OK".format(rule_id)            return False        elif document_issue < req_issue or document_issue is None:            self.logWarning("IS_1",rule_id,"")            #self.dico_warnings["WARNING","IS_1",self.current_folder,rule_id,""] = ["Status is NOT VERIFIED (verified issue is lesser than requirement/document issue or verified issue is empty)."]            #self.nb_warning += 1        elif document_issue > req_issue:            #print "if document_issue > req_issue |{:s}|{:s}|".format(document_issue,req_issue)            self.logError("IS_2",rule_id,"")            if rule_id == "SDS_111":                print "TOTO:",document_issue,remarks,reviewer,type                exit(0)            #self.dico_errors["ERROR","IS_2",self.current_folder,rule_id,""] = ["Verified version does not exist (verified issue is greater than requirement/document issue)."]            #self.nb_error += 1        else:            self.logWarning("IS_3",rule_id,remarks)            #self.dico_warnings["WARNING","IS_3",self.current_folder,rule_id,remarks] = ["Status is NOK (A remark exists)."]            #self.nb_warning += 1            #print "REMARKS:",rule_id,remarks        return True    def checkStatus(self,                    list_general_rules,                    context_issue=None,                    dico_index={"reviewer":3,                                "issue":4,                                "remark":5}):        nb_nok = 0        for rule in list_general_rules:            rule_id = rule[0]            if rule_id is not None:                # It is a true line check otherwise it is just information                #if rule_id == "SDS_001" or rule[1] == "SDS_01":                #    print "RULE",rule                #    exit(0)                reviewer = rule[dico_index["reviewer"]]                document_issue = Tool.removeBlankSpace(str(rule[dico_index["issue"]])) # version of requirement/document reviewed                remarks = rule[dico_index["remark"]]                if context_issue is not None:                    # REVIEW and DOC REVIEW                    result = self.detectError(rule_id,                                              document_issue,                       # version of requirement/document reviewed                                              Tool.removeBlankSpace(context_issue), # version of requirement/document delivered for review                                              remarks,                                              reviewer,                                              type="Rule")                    if result:                        nb_nok += 1                else:                    # REQ ANALYSIS and UPPER REQ ANALYSIS                    req_issue = rule[1]                    if 0==1:                        if type(req_issue) != type(document_issue):                            # ValueError: invalid literal for int() with base 10: '3D6'                            try:                                req_issue = int(req_issue)                                if document_issue is not None:                                    document_issue = int(document_issue)                                #else:                                #    document_issue = ""                            except ValueError:                                print "type(req_issue)",req_issue                                pass                            except TypeError:                                pass                    result = self.detectError(rule_id,                                              Tool.removeBlankSpace(Tool.removeNonAscii(document_issue)), # version of requirement/document reviewed                                              Tool.removeBlankSpace(Tool.removeNonAscii(req_issue)), # version of requirement/document delivered for review                                              remarks,                                              reviewer,                                              type="Requirement")                    if result:                        nb_nok += 1        return nb_nok    def checkReviewers(self,list_req,dico_index={"reviewer":3}):        dico_save_reviewers = {}        for row in list_req:            req_id = row[0]            reviewers = row[dico_index["reviewer"]]            if reviewers is not None:                # Split reviewer                tbl_reviewer = reviewers.split(",")                for reader in tbl_reviewer:                    reader = re.sub(r' ',r'',reader)                    if reader not in dico_save_reviewers:                        dico_save_reviewers[reader] = 1                    else:                        dico_save_reviewers[reader] += 1        effort_total = 0        for reader,effort in dico_save_reviewers.iteritems():            effort_total += effort        return dico_save_reviewers,effort_total    def checkStatusReqReview(self,                             list_reqs,                             list_srs_req_rules,                             dico_index={"req_id":0,                                         "req_issue":1,                                         "reviewer":5,                                         "issue":6,                                         "remark":7},                             type=("SWRD",)):        """        This function read matrix requirements versus rules        This function verify version of requirement reviewed match version of the requirement in first column version.        It also computes status according to the conditions:            - if a remark exists status is NOK            - if version of requirement reviewed match version of the requirement in specification document and              reviewer's name is not empty  and no remarks exist then status is OK        :param list_reqs: Ex [u'SWRD_SMS-WHCC_001', u'1.0', u'OK', None, u'Abdallah BEN MHAMED', u'Abdallah BEN MHAMED', u'3.1', None, u'Abdallah BEN MHAMED', u'3.1', None, etc.        :param list_srs_req_rules: Ex: [u'SRS_REQ_37', u'SRS_REQ_38', etc.        :param dico_index:        :return:        """        tbl_save_errors = []        nb_reqs_nok = 0        #print "tbl_list_llr",self.tbl_list_llr        for req in list_reqs:            # read each requirement            del(tbl_save_errors[:])            req_id = req[dico_index["req_id"]]            req_issue = Tool.removeBlankSpace(req[dico_index["req_issue"]])            reviewer_index = dico_index["reviewer"]            issue_index = dico_index["issue"]            remark_index = dico_index["remark"]            if self.spec_exists:                #print "REQ_ID",req_id                if req_id in self.tbl_list_llr:                    value = self.tbl_list_llr[str(req_id)]                    req_status = CheckLLR.getAtribute(value,"status")                else:                    req_status = None            else:                req_status = None            #req_status = Check_LLR.getAtribute(req,"")            #print "TYPE:",type            if "SWRD" in type:                list_rules = self.expected_srs_req_rules_dico            elif "SWDD" in type:                list_rules = self.expected_sds_req_rules_dico            for rule in list_srs_req_rules:                # read each rules                if rule in list_rules:                    alloc_rule = list_rules[rule]                else:                    alloc_rule = False                    if rule not in self.list_rules_unknown:                        self.list_rules_unknown.append(rule)                        self.logError("IS_31",req_id,rule)                if req_status == "DELETED" and alloc_rule == "Existent":                    self.logWarning("IS_24",req_id,rule)                reviewer = req[reviewer_index]                #print "REQ:",req                req_reviewed_issue = Tool.removeBlankSpace(req[issue_index])                remarks = req[remark_index]                reviewer_index += 3                issue_index += 3                remark_index += 3                self.addRemark(remarks,rule,req_id)                rule_id = re.sub(r'^S[R|D]S_REQ_([0-9]{2})',r'\1',rule)                #if rule == "SDS_REQ_103":                #    print "req_reviewed_issue < req_issue",req_reviewed_issue,req_issue,remarks,reviewer                #    exit(0)                if req_id not in (None,"None"):                    result_comp_req_reviewed_req = self.compareVersionRevision(req_reviewed_issue,req_issue)                    if req_reviewed_issue in (None,"None") and remarks in (None,"None") and reviewer in (None,"None"):                        #print "REQ ID",req_id                        #print "TEST SRS_REQ",req                        self.logWarning("IS_30",rule,"")                    elif result_comp_req_reviewed_req is "EQUAL" and remarks is None and reviewer is not None:                        # Rule is OK                        pass                        #print "Rule {:s} for {:s} is OK".format(rule,req_id)                    elif result_comp_req_reviewed_req is "INF" or reviewer is None:                        self.dico_warnings["WARNING","IS_21",self.current_folder,req_id,rule] = ["Rule status is NOT VERIFIED because verified issue is strictly lesser than requirement issue or or no reviewer is identified."]                        self.nb_warning += 1                    elif result_comp_req_reviewed_req is "SUP":                        #print "req_reviewed_issue:",req_reviewed_issue                        #print "req_issue:",req_issue                        self.dico_errors["ERROR","IS_22",self.current_folder,req_id,rule] = ["Rule status is NOT VERIFIED because verified issue {:s} is strictly greater than requirement issue {:s}.".format(req_reviewed_issue,req_issue)]                        self.nb_error += 1                        tbl_save_errors.append(rule_id)                    else:                        print ":{:s}:{:s}:{:s}:".format(result_comp_req_reviewed_req,req_reviewed_issue,req_issue)                        print "REMARK:",remarks                        print "REVIEWER:",reviewer                        self.dico_warnings["WARNING","IS_4",self.current_folder,req_id,rule] = ["Rule status is NOK because a remarks exists."]                        self.nb_warning += 1                        #exit()            if tbl_save_errors != []:                list_error_rules_str = ",".join(tbl_save_errors)                for error in tbl_save_errors:                    self.nb_error += 1                    nb_reqs_nok += 1        return nb_reqs_nok    def resetSheetsList(self):        # "CONTEXT","REVIEW","DOC REVIEW","REQ REVIEW","REQ ANALYSIS","UPPER REQ ANALYSIS","REMARKS"         self.sheets_list = self.dico_sheets["is"]    def resetKeywords(self):        self.keywords = {"gen":                        {"Project Identification":1,                         "Project Release":2,                         "Reviewers":3,                         "Date":4},                    "ids":                        {"Title":1,                         "Reference":2,                         "Issue":3,                         "Author":4,                         "Verification baseline":5},                    "docs":{},                    "crs":{}}        self.found_tag = {"GENERALITIES":False,                    "IDENTIFICATION OF VERIFIED PRODUCT":False,                    "LIST OF APPLICABLE/REFERENCE DOCUMENTS":False,                    "LIST OF CR WITH IMPACT ON DOCUMENT":False}        self.fillDico("docs","EMPTY")        self.fillDico("crs","EMPTY")    def parseContext(self,wb,deepcopy_keywords=[]):        if wb:            left_cell_label = ""            self.resetKeywords()            #print "SHEET LIST",self.sheets_list            ws = wb.get_sheet_by_name(name = self.sheets_list[0]) # ws is now an IterableWorksheet            if ws is not None:                for row in ws.iter_rows('A5:C50'): # it brings a new method: iter_rows()                    self.index_row += 1                    # New line                    self.index_column = 0                    for cell in row:                        self.index_column += 1                        #print "DEBUG  ws.iter_rows:",self.index_row,self.index_column,cell.value                        #if 0==0: #cell.value is not None:                        if cell.value in self.found_tag:                            # Found Tag                            self.found_tag[cell.value] = {"row":self.index_row,"column":self.index_column}                        else:                            # Check data                            if self.found_tag["LIST OF CR WITH IMPACT ON DOCUMENT"]:                                #print "TEST",left_cell_label,cell.value,self.found_tag["LIST OF CR WITH IMPACT ON DOCUMENT"]                                self.getValue(deepcopy_keywords,                                                  key = "crs",                                                  tag = self.found_tag["LIST OF CR WITH IMPACT ON DOCUMENT"],                                                  value = cell.value,                                                  label = left_cell_label)                            elif self.found_tag["LIST OF APPLICABLE/REFERENCE DOCUMENTS"]:                                #print "DEBUG",cell.value                                self.getValue(deepcopy_keywords,                                                  key = "docs",                                                  tag = self.found_tag["LIST OF APPLICABLE/REFERENCE DOCUMENTS"],                                                  value = cell.value,                                                  label = left_cell_label)                            elif self.found_tag["IDENTIFICATION OF VERIFIED PRODUCT"]:                                self.getValue(deepcopy_keywords,                                                  key = "ids",                                                  tag = self.found_tag["IDENTIFICATION OF VERIFIED PRODUCT"],                                                  value = cell.value)                            elif self.found_tag["GENERALITIES"]:                                self.getValue(deepcopy_keywords,                                                  key = "gen",                                                  tag = self.found_tag["GENERALITIES"],                                                  value = cell.value)                        left_cell_label = cell.valueif __name__ == '__main__':    #    # Open an existing workbook    #    import win32com.client as win32    excel = win32.gencache.EnsureDispatch('Excel.Application')    wb = excel.Workbooks.Open('C:\Users\olivier.appere\Desktop\DCENM\Copie de IS_SwRD_DCENM-1.14.0_5011137081859159507.xls')    wh=wb.Worksheets(1)    #print "TEST2:",wh    print "TEST3:",wh.Range('A2:F50').Value    for row in wh.Range('A2:F50').Value:        print row    # Alternately, specify the full path to the workbook    # wb = excel.Workbooks.Open(r'C:\myfiles\excel\workbook2.xlsx')    excel.Visible = True    if 0==1:        isr = CheckIS        input1 = "2.12"        input2 = "1.12"        version1,revision1 = isr.getVersionRevision(input1)        print version1,revision1        status = isr.compareVersionRevision(input1,input2)        print status        found_reqs_in_is = [u'SWRD_GLOBAL-BITE_0001', u'SWRD_GLOBAL-BITE_0002', u'SWRD_GLOBAL-BITE_0003', u'SWRD_GLOBAL-BITE_0004', u'SWRD_GLOBAL-BITE_0005', u'SWRD_GLOBAL-BITE_0006', u'SWRD_GLOBAL-BITE_0007', u'SWRD_GLOBAL-BITE_0010', u'SWRD_GLOBAL-BITE_0442', u'SWRD_GLOBAL-BITE_0011', u'SWRD_GLOBAL-BITE_0012', u'SWRD_GLOBAL-BITE_0013', u'SWRD_GLOBAL-BITE_0014', u'SWRD_GLOBAL-BITE_0015', u'SWRD_GLOBAL-BITE_0016', u'SWRD_GLOBAL-BITE_0017', u'SWRD_GLOBAL-BITE_0018', u'SWRD_GLOBAL-BITE_0019', u'SWRD_GLOBAL-BITE_0020', u'SWRD_GLOBAL-BITE_0021', u'SWRD_GLOBAL-BITE_0022', u'SWRD_GLOBAL-BITE_0023', u'SWRD_GLOBAL-BITE_0024', u'SWRD_GLOBAL-BITE_0025', u'SWRD_GLOBAL-BITE_0026', u'SWRD_GLOBAL-BITE_0027', u'SWRD_GLOBAL-BITE_0028', u'SWRD_GLOBAL-BITE_0029', u'SWRD_GLOBAL-BITE_0030', u'SWRD_GLOBAL-BITE_0031', u'SWRD_GLOBAL-BITE_0032', u'SWRD_GLOBAL-BITE_0033', u'SWRD_GLOBAL-BITE_0034', u'SWRD_GLOBAL-BITE_0035', u'SWRD_GLOBAL-BITE_0036', u'SWRD_GLOBAL-BITE_0037', u'SWRD_GLOBAL-BITE_0038', u'SWRD_GLOBAL-BITE_0039', u'SWRD_GLOBAL-BITE_0040', u'SWRD_GLOBAL-BITE_0041', u'SWRD_GLOBAL-BITE_0042', u'SWRD_GLOBAL-BITE_0043', u'SWRD_GLOBAL-BITE_0044', u'SWRD_GLOBAL-BITE_0045', u'SWRD_GLOBAL-BITE_0046', u'SWRD_GLOBAL-BITE_0047', u'SWRD_GLOBAL-BITE_0048', u'SWRD_GLOBAL-BITE_0049', u'SWRD_GLOBAL-BITE_0050', u'SWRD_GLOBAL-BITE_0051', u'SWRD_GLOBAL-BITE_0052', u'SWRD_GLOBAL-BITE_0053', u'SWRD_GLOBAL-BITE_0054', u'SWRD_GLOBAL-BITE_0055', u'SWRD_GLOBAL-BITE_0056', u'SWRD_GLOBAL-BITE_0057', u'SWRD_GLOBAL-BITE_0058', u'SWRD_GLOBAL-BITE_0059', u'SWRD_GLOBAL-BITE_0060', u'SWRD_GLOBAL-BITE_0061', u'SWRD_GLOBAL-BITE_0062', u'SWRD_GLOBAL-BITE_0063', u'SWRD_GLOBAL-BITE_0064', u'SWRD_GLOBAL-BITE_0065', u'SWRD_GLOBAL-BITE_0066', u'SWRD_GLOBAL-BITE_0067', u'SWRD_GLOBAL-BITE_0068', u'SWRD_GLOBAL-BITE_0069', u'SWRD_GLOBAL-BITE_0070', u'SWRD_GLOBAL-BITE_0071', u'SWRD_GLOBAL-BITE_0072', u'SWRD_GLOBAL-BITE_0073', u'SWRD_GLOBAL-BITE_0074', u'SWRD_GLOBAL-BITE_0075', u'SWRD_GLOBAL-BITE_0076', u'SWRD_GLOBAL-BITE_0077', u'SWRD_GLOBAL-BITE_0423', u'SWRD_GLOBAL-BITE_0078', u'SWRD_GLOBAL-BITE_0079', u'SWRD_GLOBAL-BITE_0080', u'SWRD_GLOBAL-BITE_0081', u'SWRD_GLOBAL-BITE_0082', u'SWRD_GLOBAL-BITE_0083', u'SWRD_GLOBAL-BITE_0084', u'SWRD_GLOBAL-BITE_0085', u'SWRD_GLOBAL-BITE_0086', u'SWRD_GLOBAL-BITE_0087', u'SWRD_GLOBAL-BITE_0424', u'SWRD_GLOBAL-BITE_0425', u'SWRD_GLOBAL-BITE_0426', u'SWRD_GLOBAL-BITE_0427', u'SWRD_GLOBAL-BITE_0428', u'SWRD_GLOBAL-BITE_0429', u'SWRD_GLOBAL-BITE_0430', u'SWRD_GLOBAL-BITE_0431', u'SWRD_GLOBAL-BITE_0432', u'SWRD_GLOBAL-BITE_0433', u'SWRD_GLOBAL-BITE_0434', u'SWRD_GLOBAL-BITE_0435', u'SWRD_GLOBAL-BITE_0436', u'SWRD_GLOBAL-BITE_0437', u'SWRD_GLOBAL-BITE_0438', u'SWRD_GLOBAL-BITE_0088', u'SWRD_GLOBAL-BITE_0439', u'SWRD_GLOBAL-BITE_0089', u'SWRD_GLOBAL-BITE_0090', u'SWRD_GLOBAL-BITE_0091', u'SWRD_GLOBAL-BITE_0092', u'SWRD_GLOBAL-BITE_0093', u'SWRD_GLOBAL-BITE_0094', u'SWRD_GLOBAL-BITE_0095', u'SWRD_GLOBAL-BITE_0448', u'SWRD_GLOBAL-BITE_0096', u'SWRD_GLOBAL-BITE_0097', u'SWRD_GLOBAL-BITE_0098', u'SWRD_GLOBAL-BITE_0449', u'SWRD_GLOBAL-BITE_0099', u'SWRD_GLOBAL-BITE_0100', u'SWRD_GLOBAL-BITE_0101', u'SWRD_GLOBAL-BITE_0102', u'SWRD_GLOBAL-BITE_0103', u'SWRD_GLOBAL-BITE_0104', u'SWRD_GLOBAL-BITE_0105', u'SWRD_GLOBAL-BITE_0106', u'SWRD_GLOBAL-BITE_0107', u'SWRD_GLOBAL-BITE_0108', u'SWRD_GLOBAL-BITE_0109', u'SWRD_GLOBAL-BITE_0110', u'SWRD_GLOBAL-BITE_0111', u'SWRD_GLOBAL-BITE_0112', u'SWRD_GLOBAL-BITE_0113', u'SWRD_GLOBAL-BITE_0114', u'SWRD_GLOBAL-BITE_0115', u'SWRD_GLOBAL-BITE_0116', u'SWRD_GLOBAL-BITE_0117', u'SWRD_GLOBAL-BITE_0118', u'SWRD_GLOBAL-BITE_0119', u'SWRD_GLOBAL-BITE_0121', u'SWRD_GLOBAL-BITE_0122', u'SWRD_GLOBAL-BITE_0123', u'SWRD_GLOBAL-BITE_0124', u'SWRD_GLOBAL-BITE_0125', u'SWRD_GLOBAL-BITE_0126', u'SWRD_GLOBAL-BITE_0127', u'SWRD_GLOBAL-BITE_0128', u'SWRD_GLOBAL-BITE_0129', u'SWRD_GLOBAL-BITE_0130', u'SWRD_GLOBAL-BITE_0131', u'SWRD_GLOBAL-BITE_0132', u'SWRD_GLOBAL-BITE_0133', u'SWRD_GLOBAL-BITE_0445', u'SWRD_GLOBAL-BITE_0134', u'SWRD_GLOBAL-BITE_0135', u'SWRD_GLOBAL-BITE_0446', u'SWRD_GLOBAL-BITE_0447', u'SWRD_GLOBAL-BITE_0136', u'SWRD_GLOBAL-BITE_0137', u'SWRD_GLOBAL-BITE_0138', u'SWRD_GLOBAL-BITE_0139', u'SWRD_GLOBAL-BITE_0140', u'SWRD_GLOBAL-BITE_0453', u'SWRD_GLOBAL-BITE_0141', u'SWRD_GLOBAL-BITE_0142', u'SWRD_GLOBAL-BITE_0143', u'SWRD_GLOBAL-BITE_0144', u'SWRD_GLOBAL-BITE_0145', u'SWRD_GLOBAL-BITE_0454', u'SWRD_GLOBAL-BITE_0146', u'SWRD_GLOBAL-BITE_0147', u'SWRD_GLOBAL-BITE_0148', u'SWRD_GLOBAL-BITE_0149', u'SWRD_GLOBAL-BITE_0150', u'SWRD_GLOBAL-BITE_0151', u'SWRD_GLOBAL-BITE_0152', u'SWRD_GLOBAL-BITE_0154', u'SWRD_GLOBAL-BITE_0155', u'SWRD_GLOBAL-BITE_0156', u'SWRD_GLOBAL-BITE_0157', u'SWRD_GLOBAL-BITE_0457', u'SWRD_GLOBAL-BITE_0158', u'SWRD_GLOBAL-BITE_0159', u'SWRD_GLOBAL-BITE_0160', u'SWRD_GLOBAL-BITE_0162', u'SWRD_GLOBAL-BITE_0163', u'SWRD_GLOBAL-BITE_0164', u'SWRD_GLOBAL-BITE_0165', u'SWRD_GLOBAL-BITE_0166', u'SWRD_GLOBAL-BITE_0167', u'SWRD_GLOBAL-BITE_0168', u'SWRD_GLOBAL-BITE_0169', u'SWRD_GLOBAL-BITE_0170', u'SWRD_GLOBAL-BITE_0171', u'SWRD_GLOBAL-BITE_0172', u'SWRD_GLOBAL-BITE_0173', u'SWRD_GLOBAL-BITE_0174', u'SWRD_GLOBAL-BITE_0175', u'SWRD_GLOBAL-BITE_0176', u'SWRD_GLOBAL-BITE_0177', u'SWRD_GLOBAL-BITE_0178', u'SWRD_GLOBAL-BITE_0179', u'SWRD_GLOBAL-BITE_0180', u'SWRD_GLOBAL-BITE_0181', u'SWRD_GLOBAL-BITE_0182', u'SWRD_GLOBAL-BITE_0183', u'SWRD_GLOBAL-BITE_0184', u'SWRD_GLOBAL-BITE_0185', u'SWRD_GLOBAL-BITE_0186', u'SWRD_GLOBAL-BITE_0187', u'SWRD_GLOBAL-BITE_0188', u'SWRD_GLOBAL-BITE_0440', u'SWRD_GLOBAL-BITE_0189', u'SWRD_GLOBAL-BITE_0460', u'SWRD_GLOBAL-BITE_0190', u'SWRD_GLOBAL-BITE_0191', u'SWRD_GLOBAL-BITE_0192', u'SWRD_GLOBAL-BITE_0193', u'SWRD_GLOBAL-BITE_0194', u'SWRD_GLOBAL-BITE_0195', u'SWRD_GLOBAL-BITE_0196', u'SWRD_GLOBAL-BITE_0197', u'SWRD_GLOBAL-BITE_0198', u'SWRD_GLOBAL-BITE_0199', u'SWRD_GLOBAL-BITE_0200', u'SWRD_GLOBAL-BITE_0201', u'SWRD_GLOBAL-BITE_0202', u'SWRD_GLOBAL-BITE_0203', u'SWRD_GLOBAL-BITE_0462', u'SWRD_GLOBAL-BITE_0204', u'SWRD_GLOBAL-BITE_0205', u'SWRD_GLOBAL-BITE_0206', u'SWRD_GLOBAL-BITE_0207', u'SWRD_GLOBAL-BITE_0208', u'SWRD_GLOBAL-BITE_0209', u'SWRD_GLOBAL-BITE_0210', u'SWRD_GLOBAL-BITE_0211', u'SWRD_GLOBAL-BITE_0212', u'SWRD_GLOBAL-BITE_0213', u'SWRD_GLOBAL-BITE_0214', u'SWRD_GLOBAL-BITE_0215', u'SWRD_GLOBAL-BITE_0216', u'SWRD_GLOBAL-BITE_0217', u'SWRD_GLOBAL-BITE_0218', u'SWRD_GLOBAL-BITE_0219', u'SWRD_GLOBAL-BITE_0220', u'SWRD_GLOBAL-BITE_0221', u'SWRD_GLOBAL-BITE_0222', u'SWRD_GLOBAL-BITE_0223', u'SWRD_GLOBAL-BITE_0461', u'SWRD_GLOBAL-BITE_0224', u'SWRD_GLOBAL-BITE_0225', u'SWRD_GLOBAL-BITE_0226', u'SWRD_GLOBAL-BITE_0227', u'SWRD_GLOBAL-BITE_0228', u'SWRD_GLOBAL-BITE_0229', u'SWRD_GLOBAL-BITE_0230', u'SWRD_GLOBAL-BITE_0231', u'SWRD_GLOBAL-BITE_0232', u'SWRD_GLOBAL-BITE_0420', u'SWRD_GLOBAL-BITE_0421', u'SWRD_GLOBAL-BITE_0450', u'SWRD_GLOBAL-BITE_0458', u'SWRD_GLOBAL-BITE_0459', u'SWRD_GLOBAL-BITE_0463', u'SWRD_GLOBAL-BITE_0464', u'SWRD_GLOBAL-BITE_0465', u'SWRD_GLOBAL-BITE_0467', u'SWRD_GLOBAL-BITE_0468', u'SWRD_GLOBAL-BITE_0233', u'SWRD_GLOBAL-BITE_0234', u'SWRD_GLOBAL-BITE_0235', u'SWRD_GLOBAL-BITE_0236', u'SWRD_GLOBAL-BITE_0237', u'SWRD_GLOBAL-BITE_0238', u'SWRD_GLOBAL-BITE_0239', u'SWRD_GLOBAL-BITE_0240', u'SWRD_GLOBAL-BITE_0241', u'SWRD_GLOBAL-BITE_0242', u'SWRD_GLOBAL-BITE_0243', u'SWRD_GLOBAL-BITE_0244', u'SWRD_GLOBAL-BITE_0456', u'SWRD_GLOBAL-BITE_0245', u'SWRD_GLOBAL-BITE_0246', u'SWRD_GLOBAL-BITE_0247', u'SWRD_GLOBAL-BITE_0248', u'SWRD_GLOBAL-BITE_0249', u'SWRD_GLOBAL-BITE_0250', u'SWRD_GLOBAL-BITE_0251', u'SWRD_GLOBAL-BITE_0252', u'SWRD_GLOBAL-BITE_0253', u'SWRD_GLOBAL-BITE_0254', u'SWRD_GLOBAL-BITE_0255', u'SWRD_GLOBAL-BITE_0256', u'SWRD_GLOBAL-BITE_0257', u'SWRD_GLOBAL-BITE_0258', u'SWRD_GLOBAL-BITE_0259', u'SWRD_GLOBAL-BITE_0260', u'SWRD_GLOBAL-BITE_0261', u'SWRD_GLOBAL-BITE_0262', u'SWRD_GLOBAL-BITE_0263', u'SWRD_GLOBAL-BITE_0264', u'SWRD_GLOBAL-BITE_0265', u'SWRD_GLOBAL-BITE_0266', u'SWRD_GLOBAL-BITE_0267', u'SWRD_GLOBAL-BITE_0268', u'SWRD_GLOBAL-BITE_0269', u'SWRD_GLOBAL-BITE_0270', u'SWRD_GLOBAL-BITE_0271', u'SWRD_GLOBAL-BITE_0272', u'SWRD_GLOBAL-BITE_0273', u'SWRD_GLOBAL-BITE_0274', u'SWRD_GLOBAL-BITE_0275', u'SWRD_GLOBAL-BITE_0276', u'SWRD_GLOBAL-BITE_0277', u'SWRD_GLOBAL-BITE_0278', u'SWRD_GLOBAL-BITE_0279', u'SWRD_GLOBAL-BITE_0280', u'SWRD_GLOBAL-BITE_0281', u'SWRD_GLOBAL-BITE_0282', u'SWRD_GLOBAL-BITE_0283', u'SWRD_GLOBAL-BITE_0284', u'SWRD_GLOBAL-BITE_0285', u'SWRD_GLOBAL-BITE_0286', u'SWRD_GLOBAL-BITE_0287', u'SWRD_GLOBAL-BITE_0288', u'SWRD_GLOBAL-BITE_0289', u'SWRD_GLOBAL-BITE_0290', u'SWRD_GLOBAL-BITE_0291', u'SWRD_GLOBAL-BITE_0292', u'SWRD_GLOBAL-BITE_0293', u'SWRD_GLOBAL-BITE_0294', u'SWRD_GLOBAL-BITE_0295', u'SWRD_GLOBAL-BITE_0296', u'SWRD_GLOBAL-BITE_0297', u'SWRD_GLOBAL-BITE_0298', u'SWRD_GLOBAL-BITE_0299', u'SWRD_GLOBAL-BITE_0300', u'SWRD_GLOBAL-BITE_0301', u'SWRD_GLOBAL-BITE_0302', u'SWRD_GLOBAL-BITE_0303', u'SWRD_GLOBAL-BITE_0304', u'SWRD_GLOBAL-BITE_0305', u'SWRD_GLOBAL-BITE_0306', u'SWRD_GLOBAL-BITE_0307', u'SWRD_GLOBAL-BITE_0308', u'SWRD_GLOBAL-BITE_0309', u'SWRD_GLOBAL-BITE_0310', u'SWRD_GLOBAL-BITE_0311', u'SWRD_GLOBAL-BITE_0312', u'SWRD_GLOBAL-BITE_0313', u'SWRD_GLOBAL-BITE_0314', u'SWRD_GLOBAL-BITE_0315', u'SWRD_GLOBAL-BITE_0316', u'SWRD_GLOBAL-BITE_0317', u'SWRD_GLOBAL-BITE_0318', u'SWRD_GLOBAL-BITE_0319', u'SWRD_GLOBAL-BITE_0320', u'SWRD_GLOBAL-BITE_0321', u'SWRD_GLOBAL-BITE_0322', u'SWRD_GLOBAL-BITE_0323', u'SWRD_GLOBAL-BITE_0324', u'SWRD_GLOBAL-BITE_0325', u'SWRD_GLOBAL-BITE_0326', u'SWRD_GLOBAL-BITE_0327', u'SWRD_GLOBAL-BITE_0328', u'SWRD_GLOBAL-BITE_0329', u'SWRD_GLOBAL-BITE_0330', u'SWRD_GLOBAL-BITE_0331', u'SWRD_GLOBAL-BITE_0332', u'SWRD_GLOBAL-BITE_0333', u'SWRD_GLOBAL-BITE_0334', u'SWRD_GLOBAL-BITE_0335', u'SWRD_GLOBAL-BITE_0336', u'SWRD_GLOBAL-BITE_0337', u'SWRD_GLOBAL-BITE_0338', u'SWRD_GLOBAL-BITE_0339', u'SWRD_GLOBAL-BITE_0340', u'SWRD_GLOBAL-BITE_0341', u'SWRD_GLOBAL-BITE_0342', u'SWRD_GLOBAL-BITE_0343', u'SWRD_GLOBAL-BITE_0344', u'SWRD_GLOBAL-BITE_0345', u'SWRD_GLOBAL-BITE_0346', u'SWRD_GLOBAL-BITE_0347', u'SWRD_GLOBAL-BITE_0348', u'SWRD_GLOBAL-BITE_0349', u'SWRD_GLOBAL-BITE_0350', u'SWRD_GLOBAL-BITE_0351', u'SWRD_GLOBAL-BITE_0352', u'SWRD_GLOBAL-BITE_0353', u'SWRD_GLOBAL-BITE_0354', u'SWRD_GLOBAL-BITE_0355', u'SWRD_GLOBAL-BITE_0356', u'SWRD_GLOBAL-BITE_0357', u'SWRD_GLOBAL-BITE_0358', u'SWRD_GLOBAL-BITE_0359', u'SWRD_GLOBAL-BITE_0360', u'SWRD_GLOBAL-BITE_0361', u'SWRD_GLOBAL-BITE_0362', u'SWRD_GLOBAL-BITE_0363', u'SWRD_GLOBAL-BITE_0364', u'SWRD_GLOBAL-BITE_0365', u'SWRD_GLOBAL-BITE_0366', u'SWRD_GLOBAL-BITE_0367', u'SWRD_GLOBAL-BITE_0368', u'SWRD_GLOBAL-BITE_0369', u'SWRD_GLOBAL-BITE_0370', u'SWRD_GLOBAL-BITE_0371', u'SWRD_GLOBAL-BITE_0372', u'SWRD_GLOBAL-BITE_0373', u'SWRD_GLOBAL-BITE_0374', u'SWRD_GLOBAL-BITE_0375', u'SWRD_GLOBAL-BITE_0376', u'SWRD_GLOBAL-BITE_0377', u'SWRD_GLOBAL-BITE_0378', u'SWRD_GLOBAL-BITE_0379', u'SWRD_GLOBAL-BITE_0380', u'SWRD_GLOBAL-BITE_0381', u'SWRD_GLOBAL-BITE_0382', u'SWRD_GLOBAL-BITE_0383', u'SWRD_GLOBAL-BITE_0384', u'SWRD_GLOBAL-BITE_0385', u'SWRD_GLOBAL-BITE_0386', u'SWRD_GLOBAL-BITE_0387', u'SWRD_GLOBAL-BITE_0388', u'SWRD_GLOBAL-BITE_0389', u'SWRD_GLOBAL-BITE_0390', u'SWRD_GLOBAL-BITE_0391', u'SWRD_GLOBAL-BITE_0392', u'SWRD_GLOBAL-BITE_0393', u'SWRD_GLOBAL-BITE_0394', u'SWRD_GLOBAL-BITE_0395', u'SWRD_GLOBAL-BITE_0396', u'SWRD_GLOBAL-BITE_0397', u'SWRD_GLOBAL-BITE_0398', u'SWRD_GLOBAL-BITE_0399', u'SWRD_GLOBAL-BITE_0400', u'SWRD_GLOBAL-BITE_0422', u'SWRD_GLOBAL-BITE_0401', u'SWRD_GLOBAL-BITE_0402', u'SWRD_GLOBAL-BITE_0403', u'SWRD_GLOBAL-BITE_0404', u'SWRD_GLOBAL-BITE_0405', u'SWRD_GLOBAL-BITE_0406', u'SWRD_GLOBAL-BITE_0407', u'SWRD_GLOBAL-BITE_0408', u'SWRD_GLOBAL-BITE_0466', u'SWRD_GLOBAL-BITE_0451', u'SWRD_GLOBAL-BITE_0444', u'SWRD_GLOBAL-BITE_0409', u'SWRD_GLOBAL-BITE_0410', u'SWRD_GLOBAL-BITE_0411', u'SWRD_GLOBAL-BITE_0153', u'SWRD_GLOBAL-BITE_0161', u'SWRD_GLOBAL-BITE_0120', u'SWRD_GLOBAL-BITE_0008', u'SWRD_GLOBAL-BITE_0009', u'SWRD_GLOBAL-BITE_0412', u'SWRD_GLOBAL-BITE_0441', u'SWRD_GLOBAL-BITE_0452', u'SWRD_GLOBAL-BITE_0455', u'SWRD_GLOBAL-BITE_0413', u'SWRD_GLOBAL-BITE_0414', u'SWRD_GLOBAL-BITE_0415', u'SWRD_GLOBAL-BITE_0416', u'SWRD_GLOBAL-BITE_0417', u'SWRD_GLOBAL-BITE_0418', u'SWRD_GLOBAL-BITE_0443', u'SWRD_GLOBAL-BITE_0419']        reqs =  [u'SWRD_GLOBAL-BITE_0001', u'SWRD_GLOBAL-BITE_0002', u'SWRD_GLOBAL-BITE_0003', u'SWRD_GLOBAL-BITE_0004', u'SWRD_GLOBAL-BITE_0005', u'SWRD_GLOBAL-BITE_0006', u'SWRD_GLOBAL-BITE_0007', u'SWRD_GLOBAL-BITE_0010', u'SWRD_GLOBAL-BITE_0442', u'SWRD_GLOBAL-BITE_0011', u'SWRD_GLOBAL-BITE_0012', u'SWRD_GLOBAL-BITE_0013', u'SWRD_GLOBAL-BITE_0014', u'SWRD_GLOBAL-BITE_0015', u'SWRD_GLOBAL-BITE_0016', u'SWRD_GLOBAL-BITE_0017', u'SWRD_GLOBAL-BITE_0018', u'SWRD_GLOBAL-BITE_0019', u'SWRD_GLOBAL-BITE_0020', u'SWRD_GLOBAL-BITE_0021', u'SWRD_GLOBAL-BITE_0025', u'SWRD_GLOBAL-BITE_0026', u'SWRD_GLOBAL-BITE_0027', u'SWRD_GLOBAL-BITE_0028', u'SWRD_GLOBAL-BITE_0029', u'SWRD_GLOBAL-BITE_0031', u'SWRD_GLOBAL-BITE_0033', u'SWRD_GLOBAL-BITE_0034', u'SWRD_GLOBAL-BITE_0035', u'SWRD_GLOBAL-BITE_0036', u'SWRD_GLOBAL-BITE_0037', u'SWRD_GLOBAL-BITE_0038', u'SWRD_GLOBAL-BITE_0039', u'SWRD_GLOBAL-BITE_0040', u'SWRD_GLOBAL-BITE_0041', u'SWRD_GLOBAL-BITE_0042', u'SWRD_GLOBAL-BITE_0043', u'SWRD_GLOBAL-BITE_0044', u'SWRD_GLOBAL-BITE_0045', u'SWRD_GLOBAL-BITE_0046', u'SWRD_GLOBAL-BITE_0047', u'SWRD_GLOBAL-BITE_0048', u'SWRD_GLOBAL-BITE_0049', u'SWRD_GLOBAL-BITE_0050', u'SWRD_GLOBAL-BITE_0051', u'SWRD_GLOBAL-BITE_0052', u'SWRD_GLOBAL-BITE_0053', u'SWRD_GLOBAL-BITE_0054', u'SWRD_GLOBAL-BITE_0055', u'SWRD_GLOBAL-BITE_0056', u'SWRD_GLOBAL-BITE_0057', u'SWRD_GLOBAL-BITE_0058', u'SWRD_GLOBAL-BITE_0059', u'SWRD_GLOBAL-BITE_0060', u'SWRD_GLOBAL-BITE_0061', u'SWRD_GLOBAL-BITE_0062', u'SWRD_GLOBAL-BITE_0063', u'SWRD_GLOBAL-BITE_0064', u'SWRD_GLOBAL-BITE_0065', u'SWRD_GLOBAL-BITE_0066', u'SWRD_GLOBAL-BITE_0067', u'SWRD_GLOBAL-BITE_0068', u'SWRD_GLOBAL-BITE_0069', u'SWRD_GLOBAL-BITE_0070', u'SWRD_GLOBAL-BITE_0071', u'SWRD_GLOBAL-BITE_0072', u'SWRD_GLOBAL-BITE_0073', u'SWRD_GLOBAL-BITE_0074', u'SWRD_GLOBAL-BITE_0075', u'SWRD_GLOBAL-BITE_0076', u'SWRD_GLOBAL-BITE_0077', u'SWRD_GLOBAL-BITE_0423', u'SWRD_GLOBAL-BITE_0078', u'SWRD_GLOBAL-BITE_0079', u'SWRD_GLOBAL-BITE_0080', u'SWRD_GLOBAL-BITE_0086', u'SWRD_GLOBAL-BITE_0087', u'SWRD_GLOBAL-BITE_0424', u'SWRD_GLOBAL-BITE_0425', u'SWRD_GLOBAL-BITE_0426', u'SWRD_GLOBAL-BITE_0427', u'SWRD_GLOBAL-BITE_0428', u'SWRD_GLOBAL-BITE_0429', u'SWRD_GLOBAL-BITE_0430', u'SWRD_GLOBAL-BITE_0431', u'SWRD_GLOBAL-BITE_0432', u'SWRD_GLOBAL-BITE_0433', u'SWRD_GLOBAL-BITE_0434', u'SWRD_GLOBAL-BITE_0435', u'SWRD_GLOBAL-BITE_0088', u'SWRD_GLOBAL-BITE_0439', u'SWRD_GLOBAL-BITE_0090', u'SWRD_GLOBAL-BITE_0091', u'SWRD_GLOBAL-BITE_0092', u'SWRD_GLOBAL-BITE_0093', u'SWRD_GLOBAL-BITE_0094', u'SWRD_GLOBAL-BITE_0526', u'SWRD_GLOBAL-BITE_0095', u'SWRD_GLOBAL-BITE_0448', u'SWRD_GLOBAL-BITE_0096', u'SWRD_GLOBAL-BITE_0097', u'SWRD_GLOBAL-BITE_0098', u'SWRD_GLOBAL-BITE_0449', u'SWRD_GLOBAL-BITE_0100', u'SWRD_GLOBAL-BITE_0101', u'SWRD_GLOBAL-BITE_0102', u'SWRD_GLOBAL-BITE_0103', u'SWRD_GLOBAL-BITE_0104', u'SWRD_GLOBAL-BITE_0105', u'SWRD_GLOBAL-BITE_0106', u'SWRD_GLOBAL-BITE_0107', u'SWRD_GLOBAL-BITE_0108', u'SWRD_GLOBAL-BITE_0109', u'SWRD_GLOBAL-BITE_0110', u'SWRD_GLOBAL-BITE_0115', u'SWRD_GLOBAL-BITE_0116', u'SWRD_GLOBAL-BITE_0117', u'SWRD_GLOBAL-BITE_0118', u'SWRD_GLOBAL-BITE_0119', u'SWRD_GLOBAL-BITE_0121', u'SWRD_GLOBAL-BITE_0122', u'SWRD_GLOBAL-BITE_0123', u'SWRD_GLOBAL-BITE_0126', u'SWRD_GLOBAL-BITE_0127', u'SWRD_GLOBAL-BITE_0128', u'SWRD_GLOBAL-BITE_0129', u'SWRD_GLOBAL-BITE_0130', u'SWRD_GLOBAL-BITE_0131', u'SWRD_GLOBAL-BITE_0132', u'SWRD_GLOBAL-BITE_0133', u'SWRD_GLOBAL-BITE_0445', u'SWRD_GLOBAL-BITE_0134', u'SWRD_GLOBAL-BITE_0135', u'SWRD_GLOBAL-BITE_0446', u'SWRD_GLOBAL-BITE_0447', u'SWRD_GLOBAL-BITE_0136', u'SWRD_GLOBAL-BITE_0137', u'SWRD_GLOBAL-BITE_0138', u'SWRD_GLOBAL-BITE_0139', u'SWRD_GLOBAL-BITE_0453', u'SWRD_GLOBAL-BITE_0141', u'SWRD_GLOBAL-BITE_0142', u'SWRD_GLOBAL-BITE_0143', u'SWRD_GLOBAL-BITE_0144', u'SWRD_GLOBAL-BITE_0145', u'SWRD_GLOBAL-BITE_0454', u'SWRD_GLOBAL-BITE_0528', u'SWRD_GLOBAL-BITE_0146', u'SWRD_GLOBAL-BITE_0147', u'SWRD_GLOBAL-BITE_0148', u'SWRD_GLOBAL-BITE_0472', u'SWRD_GLOBAL-BITE_0149', u'SWRD_GLOBAL-BITE_0150', u'SWRD_GLOBAL-BITE_0151', u'SWRD_GLOBAL-BITE_0152', u'SWRD_GLOBAL-BITE_0154', u'SWRD_GLOBAL-BITE_0155', u'SWRD_GLOBAL-BITE_0157', u'SWRD_GLOBAL-BITE_0457', u'SWRD_GLOBAL-BITE_0158', u'SWRD_GLOBAL-BITE_0159', u'SWRD_GLOBAL-BITE_0162', u'SWRD_GLOBAL-BITE_0163', u'SWRD_GLOBAL-BITE_0165', u'SWRD_GLOBAL-BITE_0156', u'SWRD_GLOBAL-BITE_0167', u'SWRD_GLOBAL-BITE_0168', u'SWRD_GLOBAL-BITE_0169', u'SWRD_GLOBAL-BITE_0170', u'SWRD_GLOBAL-BITE_0171', u'SWRD_GLOBAL-BITE_0172', u'SWRD_GLOBAL-BITE_0173', u'SWRD_GLOBAL-BITE_0174', u'SWRD_GLOBAL-BITE_0175', u'SWRD_GLOBAL-BITE_0176', u'SWRD_GLOBAL-BITE_0177', u'SWRD_GLOBAL-BITE_0178', u'SWRD_GLOBAL-BITE_0179', u'SWRD_GLOBAL-BITE_0180', u'SWRD_GLOBAL-BITE_0181', u'SWRD_GLOBAL-BITE_0182', u'SWRD_GLOBAL-BITE_0183', u'SWRD_GLOBAL-BITE_0184', u'SWRD_GLOBAL-BITE_0185', u'SWRD_GLOBAL-BITE_0186', u'SWRD_GLOBAL-BITE_0187', u'SWRD_GLOBAL-BITE_0188', u'SWRD_GLOBAL-BITE_0469', u'SWRD_GLOBAL-BITE_0440', u'SWRD_GLOBAL-BITE_0189', u'SWRD_GLOBAL-BITE_0460', u'SWRD_GLOBAL-BITE_0190', u'SWRD_GLOBAL-BITE_0191', u'SWRD_GLOBAL-BITE_0192', u'SWRD_GLOBAL-BITE_0193', u'SWRD_GLOBAL-BITE_0194', u'SWRD_GLOBAL-BITE_0195', u'SWRD_GLOBAL-BITE_0196', u'SWRD_GLOBAL-BITE_0197', u'SWRD_GLOBAL-BITE_0198', u'SWRD_GLOBAL-BITE_0199', u'SWRD_GLOBAL-BITE_0201', u'SWRD_GLOBAL-BITE_0203', u'SWRD_GLOBAL-BITE_0462', u'SWRD_GLOBAL-BITE_0204', u'SWRD_GLOBAL-BITE_0205', u'SWRD_GLOBAL-BITE_0206', u'SWRD_GLOBAL-BITE_0207', u'SWRD_GLOBAL-BITE_0208', u'SWRD_GLOBAL-BITE_0209', u'SWRD_GLOBAL-BITE_0210', u'SWRD_GLOBAL-BITE_0212', u'SWRD_GLOBAL-BITE_0213', u'SWRD_GLOBAL-BITE_0214', u'SWRD_GLOBAL-BITE_0215', u'SWRD_GLOBAL-BITE_0216', u'SWRD_GLOBAL-BITE_0217', u'SWRD_GLOBAL-BITE_0218', u'SWRD_GLOBAL-BITE_0223', u'SWRD_GLOBAL-BITE_0461', u'SWRD_GLOBAL-BITE_0224', u'SWRD_GLOBAL-BITE_0225', u'SWRD_GLOBAL-BITE_0226', u'SWRD_GLOBAL-BITE_0227', u'SWRD_GLOBAL-BITE_0228', u'SWRD_GLOBAL-BITE_0229', u'SWRD_GLOBAL-BITE_0230', u'SWRD_GLOBAL-BITE_0231', u'SWRD_GLOBAL-BITE_0450', u'SWRD_GLOBAL-BITE_0458', u'SWRD_GLOBAL-BITE_0459', u'SWRD_GLOBAL-BITE_0463', u'SWRD_GLOBAL-BITE_0464', u'SWRD_GLOBAL-BITE_0465', u'SWRD_GLOBAL-BITE_0467', u'SWRD_GLOBAL-BITE_0470', u'SWRD_GLOBAL-BITE_0468', u'SWRD_GLOBAL-BITE_0166', u'SWRD_GLOBAL-BITE_0233', u'SWRD_GLOBAL-BITE_0527', u'SWRD_GLOBAL-BITE_0234', u'SWRD_GLOBAL-BITE_0235', u'SWRD_GLOBAL-BITE_0236', u'SWRD_GLOBAL-BITE_0238', u'SWRD_GLOBAL-BITE_0239', u'SWRD_GLOBAL-BITE_0240', u'SWRD_GLOBAL-BITE_0241', u'SWRD_GLOBAL-BITE_0456', u'SWRD_GLOBAL-BITE_0245', u'SWRD_GLOBAL-BITE_0246', u'SWRD_GLOBAL-BITE_0247', u'SWRD_GLOBAL-BITE_0248', u'SWRD_GLOBAL-BITE_0249', u'SWRD_GLOBAL-BITE_0250', u'SWRD_GLOBAL-BITE_0251', u'SWRD_GLOBAL-BITE_0252', u'SWRD_GLOBAL-BITE_0254', u'SWRD_GLOBAL-BITE_0255', u'SWRD_GLOBAL-BITE_0256', u'SWRD_GLOBAL-BITE_0257', u'SWRD_GLOBAL-BITE_0258', u'SWRD_GLOBAL-BITE_0260', u'SWRD_GLOBAL-BITE_0261', u'SWRD_GLOBAL-BITE_0262', u'SWRD_GLOBAL-BITE_0263', u'SWRD_GLOBAL-BITE_0264', u'SWRD_GLOBAL-BITE_0265', u'SWRD_GLOBAL-BITE_0266', u'SWRD_GLOBAL-BITE_0267', u'SWRD_GLOBAL-BITE_0268', u'SWRD_GLOBAL-BITE_0269', u'SWRD_GLOBAL-BITE_0270', u'SWRD_GLOBAL-BITE_0271', u'SWRD_GLOBAL-BITE_0272', u'SWRD_GLOBAL-BITE_0275', u'SWRD_GLOBAL-BITE_0276', u'SWRD_GLOBAL-BITE_0277', u'SWRD_GLOBAL-BITE_0278', u'SWRD_GLOBAL-BITE_0279', u'SWRD_GLOBAL-BITE_0280', u'SWRD_GLOBAL-BITE_0281', u'SWRD_GLOBAL-BITE_0282', u'SWRD_GLOBAL-BITE_0284', u'SWRD_GLOBAL-BITE_0286', u'SWRD_GLOBAL-BITE_0288', u'SWRD_GLOBAL-BITE_0473', u'SWRD_GLOBAL-BITE_0290', u'SWRD_GLOBAL-BITE_0291', u'SWRD_GLOBAL-BITE_0292', u'SWRD_GLOBAL-BITE_0293', u'SWRD_GLOBAL-BITE_0294', u'SWRD_GLOBAL-BITE_0295', u'SWRD_GLOBAL-BITE_0296', u'SWRD_GLOBAL-BITE_0297', u'SWRD_GLOBAL-BITE_0298', u'SWRD_GLOBAL-BITE_0299', u'SWRD_GLOBAL-BITE_0300', u'SWRD_GLOBAL-BITE_0301', u'SWRD_GLOBAL-BITE_0302', u'SWRD_GLOBAL-BITE_0303', u'SWRD_GLOBAL-BITE_0304', u'SWRD_GLOBAL-BITE_0305', u'SWRD_GLOBAL-BITE_0306', u'SWRD_GLOBAL-BITE_0307', u'SWRD_GLOBAL-BITE_0308', u'SWRD_GLOBAL-BITE_0309', u'SWRD_GLOBAL-BITE_0310', u'SWRD_GLOBAL-BITE_0311', u'SWRD_GLOBAL-BITE_0312', u'SWRD_GLOBAL-BITE_0313', u'SWRD_GLOBAL-BITE_0314', u'SWRD_GLOBAL-BITE_0315', u'SWRD_GLOBAL-BITE_0316', u'SWRD_GLOBAL-BITE_0317', u'SWRD_GLOBAL-BITE_0318', u'SWRD_GLOBAL-BITE_0319', u'SWRD_GLOBAL-BITE_0320', u'SWRD_GLOBAL-BITE_0321', u'SWRD_GLOBAL-BITE_0322', u'SWRD_GLOBAL-BITE_0323', u'SWRD_GLOBAL-BITE_0324', u'SWRD_GLOBAL-BITE_0325', u'SWRD_GLOBAL-BITE_0326', u'SWRD_GLOBAL-BITE_0327', u'SWRD_GLOBAL-BITE_0328', u'SWRD_GLOBAL-BITE_0329', u'SWRD_GLOBAL-BITE_0330', u'SWRD_GLOBAL-BITE_0331', u'SWRD_GLOBAL-BITE_0332', u'SWRD_GLOBAL-BITE_0333', u'SWRD_GLOBAL-BITE_0334', u'SWRD_GLOBAL-BITE_0335', u'SWRD_GLOBAL-BITE_0336', u'SWRD_GLOBAL-BITE_0337', u'SWRD_GLOBAL-BITE_0338', u'SWRD_GLOBAL-BITE_0339', u'SWRD_GLOBAL-BITE_0340', u'SWRD_GLOBAL-BITE_0341', u'SWRD_GLOBAL-BITE_0342', u'SWRD_GLOBAL-BITE_0343', u'SWRD_GLOBAL-BITE_0344', u'SWRD_GLOBAL-BITE_0345', u'SWRD_GLOBAL-BITE_0346', u'SWRD_GLOBAL-BITE_0347', u'SWRD_GLOBAL-BITE_0348', u'SWRD_GLOBAL-BITE_0349', u'SWRD_GLOBAL-BITE_0350', u'SWRD_GLOBAL-BITE_0351', u'SWRD_GLOBAL-BITE_0471', u'SWRD_GLOBAL-BITE_0352', u'SWRD_GLOBAL-BITE_0353', u'SWRD_GLOBAL-BITE_0354', u'SWRD_GLOBAL-BITE_0358', u'SWRD_GLOBAL-BITE_0474', u'SWRD_GLOBAL-BITE_0359', u'SWRD_GLOBAL-BITE_0475', u'SWRD_GLOBAL-BITE_0360', u'SWRD_GLOBAL-BITE_0476', u'SWRD_GLOBAL-BITE_0361', u'SWRD_GLOBAL-BITE_0477', u'SWRD_GLOBAL-BITE_0362', u'SWRD_GLOBAL-BITE_0478', u'SWRD_GLOBAL-BITE_0363', u'SWRD_GLOBAL-BITE_0479', u'SWRD_GLOBAL-BITE_0364', u'SWRD_GLOBAL-BITE_0480', u'SWRD_GLOBAL-BITE_0365', u'SWRD_GLOBAL-BITE_0481', u'SWRD_GLOBAL-BITE_0366', u'SWRD_GLOBAL-BITE_0482', u'SWRD_GLOBAL-BITE_0367', u'SWRD_GLOBAL-BITE_0483', u'SWRD_GLOBAL-BITE_0368', u'SWRD_GLOBAL-BITE_0484', u'SWRD_GLOBAL-BITE_0369', u'SWRD_GLOBAL-BITE_0485', u'SWRD_GLOBAL-BITE_0370', u'SWRD_GLOBAL-BITE_0486', u'SWRD_GLOBAL-BITE_0371', u'SWRD_GLOBAL-BITE_0487', u'SWRD_GLOBAL-BITE_0372', u'SWRD_GLOBAL-BITE_0488', u'SWRD_GLOBAL-BITE_0373', u'SWRD_GLOBAL-BITE_0489', u'SWRD_GLOBAL-BITE_0374', u'SWRD_GLOBAL-BITE_0490', u'SWRD_GLOBAL-BITE_0375', u'SWRD_GLOBAL-BITE_0491', u'SWRD_GLOBAL-BITE_0376', u'SWRD_GLOBAL-BITE_0492', u'SWRD_GLOBAL-BITE_0377', u'SWRD_GLOBAL-BITE_0493', u'SWRD_GLOBAL-BITE_0378', u'SWRD_GLOBAL-BITE_0494', u'SWRD_GLOBAL-BITE_0379', u'SWRD_GLOBAL-BITE_0495', u'SWRD_GLOBAL-BITE_0380', u'SWRD_GLOBAL-BITE_0496', u'SWRD_GLOBAL-BITE_0381', u'SWRD_GLOBAL-BITE_0497', u'SWRD_GLOBAL-BITE_0382', u'SWRD_GLOBAL-BITE_0498', u'SWRD_GLOBAL-BITE_0385', u'SWRD_GLOBAL-BITE_0499', u'SWRD_GLOBAL-BITE_0386', u'SWRD_GLOBAL-BITE_0500', u'SWRD_GLOBAL-BITE_0387', u'SWRD_GLOBAL-BITE_0501', u'SWRD_GLOBAL-BITE_0388', u'SWRD_GLOBAL-BITE_0502', u'SWRD_GLOBAL-BITE_0389', u'SWRD_GLOBAL-BITE_0503', u'SWRD_GLOBAL-BITE_0390', u'SWRD_GLOBAL-BITE_0504', u'SWRD_GLOBAL-BITE_0391', u'SWRD_GLOBAL-BITE_0505', u'SWRD_GLOBAL-BITE_0392', u'SWRD_GLOBAL-BITE_0506', u'SWRD_GLOBAL-BITE_0393', u'SWRD_GLOBAL-BITE_0507', u'SWRD_GLOBAL-BITE_0394', u'SWRD_GLOBAL-BITE_0508', u'SWRD_GLOBAL-BITE_0395', u'SWRD_GLOBAL-BITE_0509', u'SWRD_GLOBAL-BITE_0396', u'SWRD_GLOBAL-BITE_0510', u'SWRD_GLOBAL-BITE_0397', u'SWRD_GLOBAL-BITE_0511', u'SWRD_GLOBAL-BITE_0398', u'SWRD_GLOBAL-BITE_0512', u'SWRD_GLOBAL-BITE_0399', u'SWRD_GLOBAL-BITE_0513', u'SWRD_GLOBAL-BITE_0400', u'SWRD_GLOBAL-BITE_0514', u'SWRD_GLOBAL-BITE_0422', u'SWRD_GLOBAL-BITE_0515', u'SWRD_GLOBAL-BITE_0401', u'SWRD_GLOBAL-BITE_0516', u'SWRD_GLOBAL-BITE_0402', u'SWRD_GLOBAL-BITE_0517', u'SWRD_GLOBAL-BITE_0403', u'SWRD_GLOBAL-BITE_0518', u'SWRD_GLOBAL-BITE_0404', u'SWRD_GLOBAL-BITE_0519', u'SWRD_GLOBAL-BITE_0405', u'SWRD_GLOBAL-BITE_0520', u'SWRD_GLOBAL-BITE_0406', u'SWRD_GLOBAL-BITE_0521', u'SWRD_GLOBAL-BITE_0407', u'SWRD_GLOBAL-BITE_0522', u'SWRD_GLOBAL-BITE_0408', u'SWRD_GLOBAL-BITE_0523', u'SWRD_GLOBAL-BITE_0466', u'SWRD_GLOBAL-BITE_0524', u'SWRD_GLOBAL-BITE_0451', u'SWRD_GLOBAL-BITE_0525', u'SWRD_GLOBAL-BITE_0357', u'SWRD_GLOBAL-BITE_0444', u'SWRD_GLOBAL-BITE_0409', u'SWRD_GLOBAL-BITE_0410', u'SWRD_GLOBAL-BITE_0411', u'SWRD_GLOBAL-BITE_0153', u'SWRD_GLOBAL-BITE_0161', u'SWRD_GLOBAL-BITE_0120', u'SWRD_GLOBAL-BITE_0008', u'SWRD_GLOBAL-BITE_0009', u'SWRD_GLOBAL-BITE_0412', u'SWRD_GLOBAL-BITE_0441', u'SWRD_GLOBAL-BITE_0452', u'SWRD_GLOBAL-BITE_0455', u'SWRD_GLOBAL-BITE_0413', u'SWRD_GLOBAL-BITE_0414', u'SWRD_GLOBAL-BITE_0415', u'SWRD_GLOBAL-BITE_0416', u'SWRD_GLOBAL-BITE_0417', u'SWRD_GLOBAL-BITE_0418', u'SWRD_GLOBAL-BITE_0443', u'SWRD_GLOBAL-BITE_0419']        print "found_reqs_in_is",len(found_reqs_in_is)        print "reqs",len(reqs)        if "SWRD_GLOBAL-BITE_0498" in found_reqs_in_is:            print "OK1"        if "SWRD_GLOBAL-BITE_0498" in reqs:            print "OK2"        is_list_reqs_w_issue = [(u'Requirements Tag', u'Colonne19', u'Colonne24'), (u'SWRD_GLOBAL-BITE_0001', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0002', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0003', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0004', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0005', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0006', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0007', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0008', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0009', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0010', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0011', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0012', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0013', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0014', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0015', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0016', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0017', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0018', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0019', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0020', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0021', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0022', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0023', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0024', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0025', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0026', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0027', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0028', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0029', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0030', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0031', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0032', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0033', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0034', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0035', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0036', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0037', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0038', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0039', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0040', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0041', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0042', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0043', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0044', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0045', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0046', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0047', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0048', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0049', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0050', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0051', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0052', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0053', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0054', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0055', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0056', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0057', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0058', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0059', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0060', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0061', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0062', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0063', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0064', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0065', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0066', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0067', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0068', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0069', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0070', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0071', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0072', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0073', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0074', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0075', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0076', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0077', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0078', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0079', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0080', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0081', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0082', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0083', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0084', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0085', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0086', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0087', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0088', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0089', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0090', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0091', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0092', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0093', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0094', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0095', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0096', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0097', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0098', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0099', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0100', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0101', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0102', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0103', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0104', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0105', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0106', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0107', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0108', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0109', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0110', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0111', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0112', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0113', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0114', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0115', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0116', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0117', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0118', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0119', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0120', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0121', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0122', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0123', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0124', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0125', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0126', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0127', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0128', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0129', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0130', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0131', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0132', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0133', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0134', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0135', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0136', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0137', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0138', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0139', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0140', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0141', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0142', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0143', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0144', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0145', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0146', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0147', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0148', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0149', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0150', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0151', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0152', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0153', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0154', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0155', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0156', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0157', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0158', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0159', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0160', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0161', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0162', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0163', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0164', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0165', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0166', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0167', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0168', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0169', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0170', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0171', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0172', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0173', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0174', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0175', 1.6, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0176', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0177', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0178', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0179', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0180', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0181', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0182', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0183', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0184', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0185', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0186', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0187', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0188', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0189', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0190', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0191', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0192', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0193', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0194', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0195', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0196', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0197', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0198', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0199', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0200', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0201', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0202', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0203', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0204', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0205', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0206', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0207', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0208', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0209', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0210', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0211', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0212', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0213', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0214', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0215', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0216', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0217', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0218', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0219', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0220', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0221', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0222', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0223', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0224', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0225', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0226', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0227', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0228', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0229', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0230', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0231', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0232', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0233', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0234', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0235', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0236', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0237', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0238', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0239', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0240', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0241', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0242', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0243', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0244', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0245', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0246', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0247', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0248', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0249', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0250', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0251', 1.2, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0252', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0253', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0254', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0255', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0256', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0257', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0258', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0259', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0260', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0261', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0262', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0263', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0264', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0265', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0266', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0267', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0268', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0269', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0270', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0271', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0272', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0273', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0274', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0275', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0276', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0277', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0278', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0279', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0280', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0281', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0282', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0283', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0284', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0285', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0286', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0287', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0288', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0289', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0290', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0291', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0292', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0293', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0294', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0295', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0296', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0297', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0298', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0299', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0300', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0301', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0302', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0303', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0304', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0305', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0306', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0307', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0308', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0309', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0310', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0311', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0312', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0313', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0314', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0315', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0316', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0317', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0318', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0319', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0320', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0321', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0322', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0323', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0324', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0325', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0326', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0327', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0328', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0329', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0330', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0331', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0332', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0333', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0334', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0335', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0336', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0337', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0338', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0339', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0340', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0341', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0342', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0343', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0344', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0345', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0346', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0347', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0348', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0349', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0350', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0351', 1.1, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0352', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0353', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0354', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0355', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0356', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0357', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0358', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0359', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0360', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0361', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0362', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0363', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0364', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0365', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0366', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0367', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0368', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0369', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0370', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0371', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0372', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0373', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0374', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0375', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0376', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0377', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0378', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0379', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0380', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0381', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0382', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0383', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0384', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0385', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0386', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0387', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0388', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0389', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0390', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0391', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0392', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0393', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0394', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0395', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0396', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0397', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0398', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0399', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0400', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0401', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0402', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0403', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0404', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0405', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0406', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0407', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0408', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0409', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0410', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0411', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0412', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0413', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0414', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0415', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0416', u'1.0', u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0417', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0418', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0419', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0420', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0421', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0422', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0423', 1.7, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0424', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0425', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0426', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0427', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0428', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0429', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0430', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0431', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0432', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0433', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0434', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0435', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0436', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0437', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0438', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0439', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0440', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0441', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0442', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0443', 1.3, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0444', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0445', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0446', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0447', 1.5, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0448', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0449', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0450', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0451', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0452', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0453', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0454', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0455', 1.9, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0456', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0457', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0458', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0459', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0460', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0461', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0462', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0463', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0464', 1.6, u'J.Hounsihoue'), (u'SWRD_GLOBAL-BITE_0465', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0466', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0467', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0468', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0469', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0470', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0471', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0472', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0473', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0474', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0475', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0476', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0477', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0478', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0479', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0480', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0481', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0482', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0483', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0484', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0485', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0486', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0487', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0488', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0489', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0490', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0491', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0492', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0493', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0494', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0495', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0496', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0497', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0498', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0499', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0500', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0501', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0502', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0503', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0504', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0505', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0506', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0507', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0508', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0509', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0510', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0511', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0512', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0513', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0514', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0515', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0516', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0517', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0518', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0519', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0520', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0521', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0522', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0523', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0524', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0525', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0526', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0527', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0528', 1.8, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0529', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0530', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0531', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0532', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0533', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0534', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0535', 1.1, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0536', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0537', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0538', 1.11, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0539', 1.12, u'N.Hafiz'), (u'SWRD_GLOBAL-BITE_0540', 1.11, u'N.Hafiz')]        for req,is_issue,is_reviewed_issue in is_list_reqs_w_issue:            print is_issue            print type(is_issue)